{"$message_type":"diagnostic","message":"expected tuple struct or tuple variant, found unit variant `Token::String`","code":{"code":"E0532","explanation":"Pattern arm did not match expected kind.\n\nErroneous code example:\n\n```compile_fail,E0532\nenum State {\n    Succeeded,\n    Failed(String),\n}\n\nfn print_on_failure(state: &State) {\n    match *state {\n        // error: expected unit struct, unit variant or constant, found tuple\n        //        variant `State::Failed`\n        State::Failed => println!(\"Failed\"),\n        _ => ()\n    }\n}\n```\n\nTo fix this error, ensure the match arm kind is the same as the expression\nmatched.\n\nFixed example:\n\n```\nenum State {\n    Succeeded,\n    Failed(String),\n}\n\nfn print_on_failure(state: &State) {\n    match *state {\n        State::Failed(ref msg) => println!(\"Failed with {}\", msg),\n        _ => ()\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"D:\\PROJECT\\chim\\crates\\chim-lexer\\src\\lib.rs","byte_start":1127,"byte_end":1133,"line_start":80,"line_end":80,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    String,","highlight_start":5,"highlight_end":11}],"label":"`Token::String` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":8277,"byte_end":8293,"line_start":255,"line_end":255,"column_start":31,"column_end":47,"is_primary":true,"text":[{"text":"        let abi = if let Some(Token::String(s)) = self.tokens.peek().map(|t| &t.token) {","highlight_start":31,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"use this syntax instead","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":8277,"byte_end":8293,"line_start":255,"line_end":255,"column_start":31,"column_end":47,"is_primary":true,"text":[{"text":"        let abi = if let Some(Token::String(s)) = self.tokens.peek().map(|t| &t.token) {","highlight_start":31,"highlight_end":47}],"label":null,"suggested_replacement":"Token::String","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing one of these tuple variants instead","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use crate::LiteralKind::String;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use chim_ast::LiteralKind::String;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `String`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":8277,"byte_end":8284,"line_start":255,"line_end":255,"column_start":31,"column_end":38,"is_primary":true,"text":[{"text":"        let abi = if let Some(Token::String(s)) = self.tokens.peek().map(|t| &t.token) {","highlight_start":31,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0532]\u001b[0m\u001b[1m\u001b[97m: expected tuple struct or tuple variant, found unit variant `Token::String`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:255:31\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m255\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let abi = if let Some(Token::String(s)) = self.tokens.peek().map(|t| &t.token) {\n    \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m::: \u001b[0mD:\\PROJECT\\chim\\crates\\chim-lexer\\src\\lib.rs:80:5\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m80\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     String,\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m------\u001b[0m \u001b[1m\u001b[96m`Token::String` defined here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use this syntax instead\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m255\u001b[0m \u001b[91m- \u001b[0m        let abi = if let Some(\u001b[91mToken::String(s)\u001b[0m) = self.tokens.peek().map(|t| &t.token) {\n\u001b[1m\u001b[96m255\u001b[0m \u001b[92m+ \u001b[0m        let abi = if let Some(\u001b[92mToken::String\u001b[0m) = self.tokens.peek().map(|t| &t.token) {\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these tuple variants instead\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use crate::LiteralKind::String;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use chim_ast::LiteralKind::String;\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `String`, refer to it directly\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m255\u001b[0m \u001b[91m- \u001b[0m        let abi = if let Some(\u001b[91mToken::\u001b[0mString(s)) = self.tokens.peek().map(|t| &t.token) {\n\u001b[1m\u001b[96m255\u001b[0m \u001b[92m+ \u001b[0m        let abi = if let Some(String(s)) = self.tokens.peek().map(|t| &t.token) {\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `lasso`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":67259,"byte_end":67264,"line_start":1927,"line_end":1927,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"    let mut interner = lasso::Rodeo::new();","highlight_start":24,"highlight_end":29}],"label":"use of unresolved module or unlinked crate `lasso`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `lasso`, use `cargo add lasso` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use chim_lexer::Rodeo;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `Rodeo`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":67259,"byte_end":67266,"line_start":1927,"line_end":1927,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"    let mut interner = lasso::Rodeo::new();","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of unresolved module or unlinked crate `lasso`\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1927:24\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1927\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let mut interner = lasso::Rodeo::new();\n     \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91muse of unresolved module or unlinked crate `lasso`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: if you wanted to use a crate named `lasso`, use `cargo add lasso` to add it to your `Cargo.toml`\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n     \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m1\u001b[0m \u001b[92m+ use chim_lexer::Rodeo;\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `Rodeo`, refer to it directly\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1927\u001b[0m \u001b[91m- \u001b[0m    let mut interner = \u001b[91mlasso::\u001b[0mRodeo::new();\n\u001b[1m\u001b[96m1927\u001b[0m \u001b[92m+ \u001b[0m    let mut interner = Rodeo::new();\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `Identifier`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":51,"byte_end":61,"line_start":1,"line_end":1,"column_start":52,"column_end":62,"is_primary":true,"text":[{"text":"use chim_lexer::{Token, SpannedToken, TokenStream, Identifier};","highlight_start":52,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":49,"byte_end":61,"line_start":1,"line_end":1,"column_start":50,"column_end":62,"is_primary":true,"text":[{"text":"use chim_lexer::{Token, SpannedToken, TokenStream, Identifier};","highlight_start":50,"highlight_end":62}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `Identifier`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1:52\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use chim_lexer::{Token, SpannedToken, TokenStream, Identifier};\n  \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[93m^^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"`TokenStream` doesn't implement `Debug`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":242,"byte_end":261,"line_start":10,"line_end":10,"column_start":5,"column_end":24,"is_primary":true,"text":[{"text":"    tokens: TokenStream,","highlight_start":5,"highlight_end":24}],"label":"the trait `Debug` is not implemented for `TokenStream`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":206,"byte_end":211,"line_start":8,"line_end":8,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"C:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\fmt\\mod.rs","byte_start":34339,"byte_end":34354,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: `TokenStream` doesn't implement `Debug`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:10:5\n   \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m8\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[derive(Debug)]\n   \u001b[1m\u001b[96m|\u001b[0m          \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[96min this derive macro expansion\u001b[0m\n \u001b[1m\u001b[96m9\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub struct Parser<'a> {\n\u001b[1m\u001b[96m10\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     tokens: TokenStream,\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Debug` is not implemented for `TokenStream`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 1 argument but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":536,"byte_end":560,"line_start":19,"line_end":19,"column_start":46,"column_end":70,"is_primary":false,"text":[{"text":"            tokens: TokenStream::new(tokens, std::mem::take(interner)),","highlight_start":46,"highlight_end":70}],"label":"unexpected argument #2","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":511,"byte_end":527,"line_start":19,"line_end":19,"column_start":21,"column_end":37,"is_primary":true,"text":[{"text":"            tokens: TokenStream::new(tokens, std::mem::take(interner)),","highlight_start":21,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"D:\\PROJECT\\chim\\crates\\chim-lexer\\src\\lib.rs","byte_start":15803,"byte_end":15806,"line_start":498,"line_end":498,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(tokens: Vec<SpannedToken>) -> Self {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra argument","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":534,"byte_end":560,"line_start":19,"line_end":19,"column_start":44,"column_end":70,"is_primary":true,"text":[{"text":"            tokens: TokenStream::new(tokens, std::mem::take(interner)),","highlight_start":44,"highlight_end":70}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m\u001b[97m: this function takes 1 argument but 2 arguments were supplied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:19:21\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m19\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             tokens: TokenStream::new(tokens, std::mem::take(interner)),\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m         \u001b[1m\u001b[96m------------------------\u001b[0m \u001b[1m\u001b[96munexpected argument #2\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: associated function defined here\n   \u001b[1m\u001b[96m--> \u001b[0mD:\\PROJECT\\chim\\crates\\chim-lexer\\src\\lib.rs:498:12\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m498\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn new(tokens: Vec<SpannedToken>) -> Self {\n    \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra argument\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m19\u001b[0m \u001b[91m- \u001b[0m            tokens: TokenStream::new(tokens\u001b[91m, std::mem::take(interner)\u001b[0m),\n \u001b[1m\u001b[96m19\u001b[0m \u001b[92m+ \u001b[0m            tokens: TokenStream::new(tokens),\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Function` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":1517,"byte_end":1525,"line_start":54,"line_end":54,"column_start":45,"column_end":53,"is_primary":true,"text":[{"text":"            Some(Token::Func) | Some(Token::Function) => self.parse_function().map(Some),","highlight_start":45,"highlight_end":53}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Function` found for enum `Token` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:54:45\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m54\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Func) | Some(Token::Function) => self.parse_function().map(Some),\n   \u001b[1m\u001b[96m|\u001b[0m                                             \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `结构体` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":1609,"byte_end":1618,"line_start":55,"line_end":55,"column_start":47,"column_end":50,"is_primary":true,"text":[{"text":"            Some(Token::Struct) | Some(Token::结构体) => self.parse_struct().map(Some),","highlight_start":47,"highlight_end":50}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `结构体` found for enum `Token` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:55:47\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Struct) | Some(Token::结构体) => self.parse_struct().map(Some),\n   \u001b[1m\u001b[96m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `枚举` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":1698,"byte_end":1704,"line_start":56,"line_end":56,"column_start":45,"column_end":47,"is_primary":true,"text":[{"text":"            Some(Token::Enum) | Some(Token::枚举) => self.parse_enum().map(Some),","highlight_start":45,"highlight_end":47}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `枚举` found for enum `Token` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:56:45\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m56\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Enum) | Some(Token::枚举) => self.parse_enum().map(Some),\n   \u001b[1m\u001b[96m|\u001b[0m                                             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `特征` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":1783,"byte_end":1789,"line_start":57,"line_end":57,"column_start":46,"column_end":48,"is_primary":true,"text":[{"text":"            Some(Token::Trait) | Some(Token::特征) => self.parse_trait().map(Some),","highlight_start":46,"highlight_end":48}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `特征` found for enum `Token` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:57:46\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m57\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Trait) | Some(Token::特征) => self.parse_trait().map(Some),\n   \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `实现` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":1868,"byte_end":1874,"line_start":58,"line_end":58,"column_start":45,"column_end":47,"is_primary":true,"text":[{"text":"            Some(Token::Impl) | Some(Token::实现) => self.parse_impl().map(Some),","highlight_start":45,"highlight_end":47}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `实现` found for enum `Token` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:58:45\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m58\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Impl) | Some(Token::实现) => self.parse_impl().map(Some),\n   \u001b[1m\u001b[96m|\u001b[0m                                             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `引入` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":1951,"byte_end":1957,"line_start":59,"line_end":59,"column_start":44,"column_end":46,"is_primary":true,"text":[{"text":"            Some(Token::Use) | Some(Token::引入) => self.parse_use().map(Some),","highlight_start":44,"highlight_end":46}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `引入` found for enum `Token` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:59:44\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m59\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Use) | Some(Token::引入) => self.parse_use().map(Some),\n   \u001b[1m\u001b[96m|\u001b[0m                                            \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `模组` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":2033,"byte_end":2039,"line_start":60,"line_end":60,"column_start":44,"column_end":46,"is_primary":true,"text":[{"text":"            Some(Token::Mod) | Some(Token::模组) => self.parse_mod().map(Some),","highlight_start":44,"highlight_end":46}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `模组` found for enum `Token` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:60:44\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m60\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Mod) | Some(Token::模组) => self.parse_mod().map(Some),\n   \u001b[1m\u001b[96m|\u001b[0m                                            \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `外部` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":2118,"byte_end":2124,"line_start":61,"line_end":61,"column_start":47,"column_end":49,"is_primary":true,"text":[{"text":"            Some(Token::Extern) | Some(Token::外部) => self.parse_extern().map(Some),","highlight_start":47,"highlight_end":49}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `外部` found for enum `Token` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:61:47\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Extern) | Some(Token::外部) => self.parse_extern().map(Some),\n   \u001b[1m\u001b[96m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `常量` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":2205,"byte_end":2211,"line_start":62,"line_end":62,"column_start":46,"column_end":48,"is_primary":true,"text":[{"text":"            Some(Token::Const) | Some(Token::常量) => self.parse_constant().map(Some),","highlight_start":46,"highlight_end":48}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `常量` found for enum `Token` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:62:46\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m62\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Const) | Some(Token::常量) => self.parse_constant().map(Some),\n   \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `静态` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":2295,"byte_end":2301,"line_start":63,"line_end":63,"column_start":47,"column_end":49,"is_primary":true,"text":[{"text":"            Some(Token::Static) | Some(Token::静态) => self.parse_static().map(Some),","highlight_start":47,"highlight_end":49}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `静态` found for enum `Token` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:63:47\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m63\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Static) | Some(Token::静态) => self.parse_static().map(Some),\n   \u001b[1m\u001b[96m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `令` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":2402,"byte_end":2405,"line_start":64,"line_end":64,"column_start":66,"column_end":67,"is_primary":true,"text":[{"text":"            Some(Token::Let) | Some(Token::LetAlt) | Some(Token::令) => {","highlight_start":66,"highlight_end":67}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `令` found for enum `Token` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:64:66\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m64\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Let) | Some(Token::LetAlt) | Some(Token::令) => {\n   \u001b[1m\u001b[96m|\u001b[0m                                                                  \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":2643,"byte_end":2678,"line_start":69,"line_end":69,"column_start":21,"column_end":56,"is_primary":true,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":21,"highlight_end":56}],"label":"expected `ChimError`, found `&ChimError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":2639,"byte_end":2642,"line_start":69,"line_end":69,"column_start":17,"column_end":20,"is_primary":false,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":17,"highlight_end":20}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`ChimError` does not implement `Clone`, so `&ChimError` was cloned instead","code":null,"level":"note","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":2643,"byte_end":2670,"line_start":69,"line_end":69,"column_start":21,"column_end":48,"is_primary":true,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":21,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the type constructed contains `&ChimError` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":2643,"byte_end":2678,"line_start":69,"line_end":69,"column_start":21,"column_end":56,"is_primary":false,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":21,"highlight_end":56}],"label":"this argument influences the type of `Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":2639,"byte_end":2679,"line_start":69,"line_end":69,"column_start":17,"column_end":57,"is_primary":true,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":17,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\result.rs","byte_start":21514,"byte_end":21517,"line_start":566,"line_end":566,"column_start":5,"column_end":8,"is_primary":true,"text":[{"text":"    Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),","highlight_start":5,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:69:21\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m69\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(self.errors.last().unwrap().clone())\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `ChimError`, found `&ChimError`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: `ChimError` does not implement `Clone`, so `&ChimError` was cloned instead\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:69:21\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m69\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(self.errors.last().unwrap().clone())\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `&ChimError` due to the type of the argument passed\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:69:17\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m69\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(self.errors.last().unwrap().clone())\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96m^^^^\u001b[0m\u001b[1m\u001b[96m-----------------------------------\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[96mthis argument influences the type of `Err`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\result.rs:566:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m566\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[92m^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":4201,"byte_end":4209,"line_start":120,"line_end":120,"column_start":13,"column_end":21,"is_primary":true,"text":[{"text":"            generics,","highlight_start":13,"highlight_end":21}],"label":"expected `Vec<GenericParam>`, found `Vec<LifetimeParam>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Vec<GenericParam>`\n   found struct `Vec<chim_ast::LifetimeParam>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:120:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m120\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             generics,\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Vec<GenericParam>`, found `Vec<LifetimeParam>`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `Vec<\u001b[1m\u001b[35mGenericParam\u001b[0m>`\n               found struct `Vec<\u001b[1m\u001b[35mchim_ast::LifetimeParam\u001b[0m>`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":4866,"byte_end":4874,"line_start":142,"line_end":142,"column_start":13,"column_end":21,"is_primary":true,"text":[{"text":"            generics,","highlight_start":13,"highlight_end":21}],"label":"expected `Vec<GenericParam>`, found `Vec<LifetimeParam>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Vec<GenericParam>`\n   found struct `Vec<chim_ast::LifetimeParam>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:142:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m142\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             generics,\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Vec<GenericParam>`, found `Vec<LifetimeParam>`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `Vec<\u001b[1m\u001b[35mGenericParam\u001b[0m>`\n               found struct `Vec<\u001b[1m\u001b[35mchim_ast::LifetimeParam\u001b[0m>`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":5581,"byte_end":5589,"line_start":165,"line_end":165,"column_start":13,"column_end":21,"is_primary":true,"text":[{"text":"            generics,","highlight_start":13,"highlight_end":21}],"label":"expected `Vec<GenericParam>`, found `Vec<LifetimeParam>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Vec<GenericParam>`\n   found struct `Vec<chim_ast::LifetimeParam>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:165:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m165\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             generics,\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Vec<GenericParam>`, found `Vec<LifetimeParam>`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `Vec<\u001b[1m\u001b[35mGenericParam\u001b[0m>`\n               found struct `Vec<\u001b[1m\u001b[35mchim_ast::LifetimeParam\u001b[0m>`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":6266,"byte_end":6274,"line_start":188,"line_end":188,"column_start":13,"column_end":21,"is_primary":true,"text":[{"text":"            generics,","highlight_start":13,"highlight_end":21}],"label":"expected `Vec<GenericParam>`, found `Vec<LifetimeParam>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Vec<GenericParam>`\n   found struct `Vec<chim_ast::LifetimeParam>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:188:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m188\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             generics,\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Vec<GenericParam>`, found `Vec<LifetimeParam>`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `Vec<\u001b[1m\u001b[35mGenericParam\u001b[0m>`\n               found struct `Vec<\u001b[1m\u001b[35mchim_ast::LifetimeParam\u001b[0m>`\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Function` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":15734,"byte_end":15742,"line_start":483,"line_end":483,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"                Some(Token::Func) | Some(Token::Function) => {","highlight_start":49,"highlight_end":57}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Function` found for enum `Token` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:483:49\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m483\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Some(Token::Func) | Some(Token::Function) => {\n    \u001b[1m\u001b[96m|\u001b[0m                                                 \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `常量` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":15934,"byte_end":15940,"line_start":487,"line_end":487,"column_start":50,"column_end":52,"is_primary":true,"text":[{"text":"                Some(Token::Const) | Some(Token::常量) => {","highlight_start":50,"highlight_end":52}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `常量` found for enum `Token` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:487:50\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m487\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Some(Token::Const) | Some(Token::常量) => {\n    \u001b[1m\u001b[96m|\u001b[0m                                                  \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `类型` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":16790,"byte_end":16796,"line_start":506,"line_end":506,"column_start":49,"column_end":51,"is_primary":true,"text":[{"text":"                Some(Token::Type) | Some(Token::类型) => {","highlight_start":49,"highlight_end":51}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `类型` found for enum `Token` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:506:49\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m506\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Some(Token::Type) | Some(Token::类型) => {\n    \u001b[1m\u001b[96m|\u001b[0m                                                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":17478,"byte_end":17493,"line_start":520,"line_end":520,"column_start":35,"column_end":50,"is_primary":true,"text":[{"text":"                            kind: TypeKind::Infer,","highlight_start":35,"highlight_end":50}],"label":"expected `Box<TypeKind>`, found `TypeKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::TypeKind>`\n     found enum `chim_ast::TypeKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":17478,"byte_end":17478,"line_start":520,"line_end":520,"column_start":35,"column_end":35,"is_primary":true,"text":[{"text":"                            kind: TypeKind::Infer,","highlight_start":35,"highlight_end":35}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":17493,"byte_end":17493,"line_start":520,"line_end":520,"column_start":50,"column_end":50,"is_primary":true,"text":[{"text":"                            kind: TypeKind::Infer,","highlight_start":50,"highlight_end":50}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:520:35\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m520\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   kind: TypeKind::Infer,\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<TypeKind>`, found `TypeKind`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::TypeKind\u001b[1m\u001b[35m>\u001b[0m`\n                 found enum `chim_ast::TypeKind`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m520\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                            kind: \u001b[92mBox::new(\u001b[0mTypeKind::Infer\u001b[92m)\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[92m+++++++++\u001b[0m               \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Function` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":18398,"byte_end":18406,"line_start":546,"line_end":546,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"                Some(Token::Func) | Some(Token::Function) => {","highlight_start":49,"highlight_end":57}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Function` found for enum `Token` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:546:49\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m546\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Some(Token::Func) | Some(Token::Function) => {\n    \u001b[1m\u001b[96m|\u001b[0m                                                 \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `常量` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":18598,"byte_end":18604,"line_start":550,"line_end":550,"column_start":50,"column_end":52,"is_primary":true,"text":[{"text":"                Some(Token::Const) | Some(Token::常量) => {","highlight_start":50,"highlight_end":52}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `常量` found for enum `Token` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:550:50\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m550\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Some(Token::Const) | Some(Token::常量) => {\n    \u001b[1m\u001b[96m|\u001b[0m                                                  \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `类型` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":19377,"byte_end":19383,"line_start":567,"line_end":567,"column_start":49,"column_end":51,"is_primary":true,"text":[{"text":"                Some(Token::Type) | Some(Token::类型) => {","highlight_start":49,"highlight_end":51}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `类型` found for enum `Token` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:567:49\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m567\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Some(Token::Type) | Some(Token::类型) => {\n    \u001b[1m\u001b[96m|\u001b[0m                                                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `令` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":22168,"byte_end":22171,"line_start":655,"line_end":655,"column_start":66,"column_end":67,"is_primary":true,"text":[{"text":"            Some(Token::Let) | Some(Token::LetAlt) | Some(Token::令) => self.parse_let_stmt(),","highlight_start":66,"highlight_end":67}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `令` found for enum `Token` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:655:66\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m655\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Let) | Some(Token::LetAlt) | Some(Token::令) => self.parse_let_stmt(),\n    \u001b[1m\u001b[96m|\u001b[0m                                                                  \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `返回` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":22245,"byte_end":22251,"line_start":656,"line_end":656,"column_start":47,"column_end":49,"is_primary":true,"text":[{"text":"            Some(Token::Return) | Some(Token::返回) => self.parse_return_stmt(),","highlight_start":47,"highlight_end":49}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `返回` found for enum `Token` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:656:47\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m656\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Return) | Some(Token::返回) => self.parse_return_stmt(),\n    \u001b[1m\u001b[96m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `中断` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":22327,"byte_end":22333,"line_start":657,"line_end":657,"column_start":46,"column_end":48,"is_primary":true,"text":[{"text":"            Some(Token::Break) | Some(Token::中断) => self.parse_break_stmt(),","highlight_start":46,"highlight_end":48}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `中断` found for enum `Token` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:657:46\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m657\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Break) | Some(Token::中断) => self.parse_break_stmt(),\n    \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `继续` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":22411,"byte_end":22417,"line_start":658,"line_end":658,"column_start":49,"column_end":51,"is_primary":true,"text":[{"text":"            Some(Token::Continue) | Some(Token::继续) => self.parse_continue_stmt(),","highlight_start":49,"highlight_end":51}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `继续` found for enum `Token` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:658:49\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m658\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Continue) | Some(Token::继续) => self.parse_continue_stmt(),\n    \u001b[1m\u001b[96m|\u001b[0m                                                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `While` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":22531,"byte_end":22536,"line_start":660,"line_end":660,"column_start":25,"column_end":30,"is_primary":true,"text":[{"text":"            Some(Token::While) => self.parse_while_stmt(),","highlight_start":25,"highlight_end":30}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `While` found for enum `Token` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:660:25\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m660\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::While) => self.parse_while_stmt(),\n    \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":22810,"byte_end":22984,"line_start":666,"line_end":670,"column_start":31,"column_end":27,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Block(BlockExpr {","highlight_start":31,"highlight_end":58},{"text":"                            label: None,","highlight_start":1,"highlight_end":41},{"text":"                            stmts: body,","highlight_start":1,"highlight_end":41},{"text":"                            ty: None,","highlight_start":1,"highlight_end":38},{"text":"                        }),","highlight_start":1,"highlight_end":27}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":22810,"byte_end":22810,"line_start":666,"line_end":666,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Block(BlockExpr {","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":22984,"byte_end":22984,"line_start":670,"line_end":670,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                        }),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:666:31\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m666\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                           kind: ExprKind::Block(BlockExpr {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________________^\u001b[0m\n\u001b[1m\u001b[96m667\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             label: None,\n\u001b[1m\u001b[96m668\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             stmts: body,\n\u001b[1m\u001b[96m669\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             ty: None,\n\u001b[1m\u001b[96m670\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         }),\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                 found enum `chim_ast::ExprKind`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m666\u001b[0m \u001b[92m~ \u001b[0m                        kind: \u001b[92mBox::new(\u001b[0mExprKind::Block(BlockExpr {\n\u001b[1m\u001b[96m667\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             label: None,\n\u001b[1m\u001b[96m668\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             stmts: body,\n\u001b[1m\u001b[96m669\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             ty: None,\n\u001b[1m\u001b[96m670\u001b[0m \u001b[92m~ \u001b[0m                        })\u001b[92m)\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":24814,"byte_end":24819,"line_start":732,"line_end":732,"column_start":36,"column_end":41,"is_primary":true,"text":[{"text":"            kind: StmtKind::Return(value),","highlight_start":36,"highlight_end":41}],"label":"expected `Option<Expr>`, found `Option<Box<Expr>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":24797,"byte_end":24813,"line_start":732,"line_end":732,"column_start":19,"column_end":35,"is_primary":false,"text":[{"text":"            kind: StmtKind::Return(value),","highlight_start":19,"highlight_end":35}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `Option<chim_ast::Expr>`\n   found enum `Option<Box<chim_ast::Expr>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"D:\\PROJECT\\chim\\crates\\chim-ast\\src\\lib.rs","byte_start":4085,"byte_end":4091,"line_start":205,"line_end":205,"column_start":5,"column_end":11,"is_primary":true,"text":[{"text":"    Return(Option<Expr>),","highlight_start":5,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:732:36\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m732\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             kind: StmtKind::Return(value),\n    \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[96m----------------\u001b[0m \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<Expr>`, found `Option<Box<Expr>>`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected enum `Option<chim_ast::Expr>`\n               found enum `Option<\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::Expr\u001b[1m\u001b[35m>\u001b[0m>`\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[96m--> \u001b[0mD:\\PROJECT\\chim\\crates\\chim-ast\\src\\lib.rs:205:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m205\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Return(Option<Expr>),\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this enum variant takes 1 argument but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":25298,"byte_end":25303,"line_start":749,"line_end":749,"column_start":41,"column_end":46,"is_primary":false,"text":[{"text":"            kind: StmtKind::Break(None, value),","highlight_start":41,"highlight_end":46}],"label":"unexpected argument #2 of type `Option<Box<chim_ast::Expr>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":25276,"byte_end":25291,"line_start":749,"line_end":749,"column_start":19,"column_end":34,"is_primary":true,"text":[{"text":"            kind: StmtKind::Break(None, value),","highlight_start":19,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"D:\\PROJECT\\chim\\crates\\chim-ast\\src\\lib.rs","byte_start":4111,"byte_end":4116,"line_start":206,"line_end":206,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    Break(Option<Expr>),","highlight_start":5,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra argument","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":25296,"byte_end":25303,"line_start":749,"line_end":749,"column_start":39,"column_end":46,"is_primary":true,"text":[{"text":"            kind: StmtKind::Break(None, value),","highlight_start":39,"highlight_end":46}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m\u001b[97m: this enum variant takes 1 argument but 2 arguments were supplied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:749:19\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m749\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             kind: StmtKind::Break(None, value),\n    \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m       \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[96munexpected argument #2 of type `Option<Box<chim_ast::Expr>>`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[96m--> \u001b[0mD:\\PROJECT\\chim\\crates\\chim-ast\\src\\lib.rs:206:5\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m206\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Break(Option<Expr>),\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[92m^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra argument\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m749\u001b[0m \u001b[91m- \u001b[0m            kind: StmtKind::Break(None\u001b[91m, value\u001b[0m),\n\u001b[1m\u001b[96m749\u001b[0m \u001b[92m+ \u001b[0m            kind: StmtKind::Break(None),\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `In` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":26702,"byte_end":26704,"line_start":803,"line_end":803,"column_start":28,"column_end":30,"is_primary":true,"text":[{"text":"        self.expect(Token::In)?;","highlight_start":28,"highlight_end":30}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a variant with a similar name","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":26702,"byte_end":26704,"line_start":803,"line_end":803,"column_start":28,"column_end":30,"is_primary":true,"text":[{"text":"        self.expect(Token::In)?;","highlight_start":28,"highlight_end":30}],"label":null,"suggested_replacement":"If","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `In` found for enum `Token` in the current scope\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:803:28\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m803\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         self.expect(Token::In)?;\n    \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a variant with a similar name\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m803\u001b[0m \u001b[91m- \u001b[0m        self.expect(Token::\u001b[91mIn\u001b[0m)?;\n\u001b[1m\u001b[96m803\u001b[0m \u001b[92m+ \u001b[0m        self.expect(Token::\u001b[92mIf\u001b[0m)?;\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":27490,"byte_end":27636,"line_start":831,"line_end":834,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Assign(AssignExpr {","highlight_start":27,"highlight_end":56},{"text":"                        left: Box::new(left),","highlight_start":1,"highlight_end":46},{"text":"                        right: Box::new(right),","highlight_start":1,"highlight_end":48},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":27490,"byte_end":27490,"line_start":831,"line_end":831,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Assign(AssignExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":27636,"byte_end":27636,"line_start":834,"line_end":834,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:831:27\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m831\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Assign(AssignExpr {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m832\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m833\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m834\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                 found enum `chim_ast::ExprKind`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m831\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Assign(AssignExpr {\n\u001b[1m\u001b[96m832\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m833\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m834\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":28163,"byte_end":28341,"line_start":845,"line_end":849,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::AssignOp(AssignOpExpr {","highlight_start":27,"highlight_end":60},{"text":"                        left: Box::new(left),","highlight_start":1,"highlight_end":46},{"text":"                        op,","highlight_start":1,"highlight_end":28},{"text":"                        right: Box::new(right),","highlight_start":1,"highlight_end":48},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":28163,"byte_end":28163,"line_start":845,"line_end":845,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::AssignOp(AssignOpExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":28341,"byte_end":28341,"line_start":849,"line_end":849,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:845:27\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m845\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::AssignOp(AssignOpExpr {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m846\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m847\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         op,\n\u001b[1m\u001b[96m848\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m849\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                 found enum `chim_ast::ExprKind`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m845\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::AssignOp(AssignOpExpr {\n\u001b[1m\u001b[96m846\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m847\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         op,\n\u001b[1m\u001b[96m848\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m849\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":29864,"byte_end":30032,"line_start":887,"line_end":891,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Range(RangeExpr {","highlight_start":27,"highlight_end":54},{"text":"                        start: Some(Box::new(start)),","highlight_start":1,"highlight_end":54},{"text":"                        end,","highlight_start":1,"highlight_end":29},{"text":"                        inclusive,","highlight_start":1,"highlight_end":35},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":29864,"byte_end":29864,"line_start":887,"line_end":887,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Range(RangeExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":30032,"byte_end":30032,"line_start":891,"line_end":891,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:887:27\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m887\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Range(RangeExpr {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m888\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         start: Some(Box::new(start)),\n\u001b[1m\u001b[96m889\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         end,\n\u001b[1m\u001b[96m890\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         inclusive,\n\u001b[1m\u001b[96m891\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                 found enum `chim_ast::ExprKind`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m887\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Range(RangeExpr {\n\u001b[1m\u001b[96m888\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         start: Some(Box::new(start)),\n\u001b[1m\u001b[96m889\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         end,\n\u001b[1m\u001b[96m890\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         inclusive,\n\u001b[1m\u001b[96m891\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":30518,"byte_end":30687,"line_start":907,"line_end":911,"column_start":23,"column_end":19,"is_primary":true,"text":[{"text":"                kind: ExprKind::Binary(BinaryExpr {","highlight_start":23,"highlight_end":52},{"text":"                    left: Box::new(left),","highlight_start":1,"highlight_end":42},{"text":"                    op: BinOp::Or,","highlight_start":1,"highlight_end":35},{"text":"                    right: Box::new(right),","highlight_start":1,"highlight_end":44},{"text":"                }),","highlight_start":1,"highlight_end":19}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":30518,"byte_end":30518,"line_start":907,"line_end":907,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                kind: ExprKind::Binary(BinaryExpr {","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":30687,"byte_end":30687,"line_start":911,"line_end":911,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"                }),","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:907:23\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m907\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                   kind: ExprKind::Binary(BinaryExpr {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________^\u001b[0m\n\u001b[1m\u001b[96m908\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     left: Box::new(left),\n\u001b[1m\u001b[96m909\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     op: BinOp::Or,\n\u001b[1m\u001b[96m910\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     right: Box::new(right),\n\u001b[1m\u001b[96m911\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 }),\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                 found enum `chim_ast::ExprKind`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m907\u001b[0m \u001b[92m~ \u001b[0m                kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m908\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     left: Box::new(left),\n\u001b[1m\u001b[96m909\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     op: BinOp::Or,\n\u001b[1m\u001b[96m910\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     right: Box::new(right),\n\u001b[1m\u001b[96m911\u001b[0m \u001b[92m~ \u001b[0m                })\u001b[92m)\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":31137,"byte_end":31307,"line_start":927,"line_end":931,"column_start":23,"column_end":19,"is_primary":true,"text":[{"text":"                kind: ExprKind::Binary(BinaryExpr {","highlight_start":23,"highlight_end":52},{"text":"                    left: Box::new(left),","highlight_start":1,"highlight_end":42},{"text":"                    op: BinOp::And,","highlight_start":1,"highlight_end":36},{"text":"                    right: Box::new(right),","highlight_start":1,"highlight_end":44},{"text":"                }),","highlight_start":1,"highlight_end":19}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":31137,"byte_end":31137,"line_start":927,"line_end":927,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                kind: ExprKind::Binary(BinaryExpr {","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":31307,"byte_end":31307,"line_start":931,"line_end":931,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"                }),","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:927:23\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m927\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                   kind: ExprKind::Binary(BinaryExpr {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________^\u001b[0m\n\u001b[1m\u001b[96m928\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     left: Box::new(left),\n\u001b[1m\u001b[96m929\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     op: BinOp::And,\n\u001b[1m\u001b[96m930\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     right: Box::new(right),\n\u001b[1m\u001b[96m931\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 }),\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                 found enum `chim_ast::ExprKind`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m927\u001b[0m \u001b[92m~ \u001b[0m                kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m928\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     left: Box::new(left),\n\u001b[1m\u001b[96m929\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     op: BinOp::And,\n\u001b[1m\u001b[96m930\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     right: Box::new(right),\n\u001b[1m\u001b[96m931\u001b[0m \u001b[92m~ \u001b[0m                })\u001b[92m)\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":31756,"byte_end":31928,"line_start":947,"line_end":951,"column_start":23,"column_end":19,"is_primary":true,"text":[{"text":"                kind: ExprKind::Binary(BinaryExpr {","highlight_start":23,"highlight_end":52},{"text":"                    left: Box::new(left),","highlight_start":1,"highlight_end":42},{"text":"                    op: BinOp::BitOr,","highlight_start":1,"highlight_end":38},{"text":"                    right: Box::new(right),","highlight_start":1,"highlight_end":44},{"text":"                }),","highlight_start":1,"highlight_end":19}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":31756,"byte_end":31756,"line_start":947,"line_end":947,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                kind: ExprKind::Binary(BinaryExpr {","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":31928,"byte_end":31928,"line_start":951,"line_end":951,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"                }),","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:947:23\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m947\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                   kind: ExprKind::Binary(BinaryExpr {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________^\u001b[0m\n\u001b[1m\u001b[96m948\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     left: Box::new(left),\n\u001b[1m\u001b[96m949\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     op: BinOp::BitOr,\n\u001b[1m\u001b[96m950\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     right: Box::new(right),\n\u001b[1m\u001b[96m951\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 }),\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                 found enum `chim_ast::ExprKind`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m947\u001b[0m \u001b[92m~ \u001b[0m                kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m948\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     left: Box::new(left),\n\u001b[1m\u001b[96m949\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     op: BinOp::BitOr,\n\u001b[1m\u001b[96m950\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     right: Box::new(right),\n\u001b[1m\u001b[96m951\u001b[0m \u001b[92m~ \u001b[0m                })\u001b[92m)\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":32379,"byte_end":32552,"line_start":967,"line_end":971,"column_start":23,"column_end":19,"is_primary":true,"text":[{"text":"                kind: ExprKind::Binary(BinaryExpr {","highlight_start":23,"highlight_end":52},{"text":"                    left: Box::new(left),","highlight_start":1,"highlight_end":42},{"text":"                    op: BinOp::BitXor,","highlight_start":1,"highlight_end":39},{"text":"                    right: Box::new(right),","highlight_start":1,"highlight_end":44},{"text":"                }),","highlight_start":1,"highlight_end":19}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":32379,"byte_end":32379,"line_start":967,"line_end":967,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                kind: ExprKind::Binary(BinaryExpr {","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":32552,"byte_end":32552,"line_start":971,"line_end":971,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"                }),","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:967:23\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m967\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                   kind: ExprKind::Binary(BinaryExpr {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________^\u001b[0m\n\u001b[1m\u001b[96m968\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     left: Box::new(left),\n\u001b[1m\u001b[96m969\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     op: BinOp::BitXor,\n\u001b[1m\u001b[96m970\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     right: Box::new(right),\n\u001b[1m\u001b[96m971\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 }),\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                 found enum `chim_ast::ExprKind`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m967\u001b[0m \u001b[92m~ \u001b[0m                kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m968\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     left: Box::new(left),\n\u001b[1m\u001b[96m969\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     op: BinOp::BitXor,\n\u001b[1m\u001b[96m970\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     right: Box::new(right),\n\u001b[1m\u001b[96m971\u001b[0m \u001b[92m~ \u001b[0m                })\u001b[92m)\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":33005,"byte_end":33178,"line_start":987,"line_end":991,"column_start":23,"column_end":19,"is_primary":true,"text":[{"text":"                kind: ExprKind::Binary(BinaryExpr {","highlight_start":23,"highlight_end":52},{"text":"                    left: Box::new(left),","highlight_start":1,"highlight_end":42},{"text":"                    op: BinOp::BitAnd,","highlight_start":1,"highlight_end":39},{"text":"                    right: Box::new(right),","highlight_start":1,"highlight_end":44},{"text":"                }),","highlight_start":1,"highlight_end":19}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":33005,"byte_end":33005,"line_start":987,"line_end":987,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                kind: ExprKind::Binary(BinaryExpr {","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":33178,"byte_end":33178,"line_start":991,"line_end":991,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"                }),","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:987:23\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m987\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                   kind: ExprKind::Binary(BinaryExpr {\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________^\u001b[0m\n\u001b[1m\u001b[96m988\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     left: Box::new(left),\n\u001b[1m\u001b[96m989\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     op: BinOp::BitAnd,\n\u001b[1m\u001b[96m990\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     right: Box::new(right),\n\u001b[1m\u001b[96m991\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 }),\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                 found enum `chim_ast::ExprKind`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m987\u001b[0m \u001b[92m~ \u001b[0m                kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m988\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     left: Box::new(left),\n\u001b[1m\u001b[96m989\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     op: BinOp::BitAnd,\n\u001b[1m\u001b[96m990\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     right: Box::new(right),\n\u001b[1m\u001b[96m991\u001b[0m \u001b[92m~ \u001b[0m                })\u001b[92m)\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":33634,"byte_end":33819,"line_start":1008,"line_end":1012,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Binary(BinaryExpr {","highlight_start":27,"highlight_end":56},{"text":"                        left: Box::new(left),","highlight_start":1,"highlight_end":46},{"text":"                        op: BinOp::Eq,","highlight_start":1,"highlight_end":39},{"text":"                        right: Box::new(right),","highlight_start":1,"highlight_end":48},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":33634,"byte_end":33634,"line_start":1008,"line_end":1008,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Binary(BinaryExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":33819,"byte_end":33819,"line_start":1012,"line_end":1012,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1008:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1008\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Binary(BinaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1009\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m1010\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         op: BinOp::Eq,\n\u001b[1m\u001b[96m1011\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m1012\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1008\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m1009\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m1010\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         op: BinOp::Eq,\n\u001b[1m\u001b[96m1011\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m1012\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":34097,"byte_end":34282,"line_start":1021,"line_end":1025,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Binary(BinaryExpr {","highlight_start":27,"highlight_end":56},{"text":"                        left: Box::new(left),","highlight_start":1,"highlight_end":46},{"text":"                        op: BinOp::Ne,","highlight_start":1,"highlight_end":39},{"text":"                        right: Box::new(right),","highlight_start":1,"highlight_end":48},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":34097,"byte_end":34097,"line_start":1021,"line_end":1021,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Binary(BinaryExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":34282,"byte_end":34282,"line_start":1025,"line_end":1025,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1021:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1021\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Binary(BinaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1022\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m1023\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         op: BinOp::Ne,\n\u001b[1m\u001b[96m1024\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m1025\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1021\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m1022\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m1023\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         op: BinOp::Ne,\n\u001b[1m\u001b[96m1024\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m1025\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":34559,"byte_end":34744,"line_start":1034,"line_end":1038,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Binary(BinaryExpr {","highlight_start":27,"highlight_end":56},{"text":"                        left: Box::new(left),","highlight_start":1,"highlight_end":46},{"text":"                        op: BinOp::Lt,","highlight_start":1,"highlight_end":39},{"text":"                        right: Box::new(right),","highlight_start":1,"highlight_end":48},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":34559,"byte_end":34559,"line_start":1034,"line_end":1034,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Binary(BinaryExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":34744,"byte_end":34744,"line_start":1038,"line_end":1038,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1034:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1034\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Binary(BinaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1035\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m1036\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         op: BinOp::Lt,\n\u001b[1m\u001b[96m1037\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m1038\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1034\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m1035\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m1036\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         op: BinOp::Lt,\n\u001b[1m\u001b[96m1037\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m1038\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":35022,"byte_end":35207,"line_start":1047,"line_end":1051,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Binary(BinaryExpr {","highlight_start":27,"highlight_end":56},{"text":"                        left: Box::new(left),","highlight_start":1,"highlight_end":46},{"text":"                        op: BinOp::Le,","highlight_start":1,"highlight_end":39},{"text":"                        right: Box::new(right),","highlight_start":1,"highlight_end":48},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":35022,"byte_end":35022,"line_start":1047,"line_end":1047,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Binary(BinaryExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":35207,"byte_end":35207,"line_start":1051,"line_end":1051,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1047:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1047\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Binary(BinaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1048\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m1049\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         op: BinOp::Le,\n\u001b[1m\u001b[96m1050\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m1051\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1047\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m1048\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m1049\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         op: BinOp::Le,\n\u001b[1m\u001b[96m1050\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m1051\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":35484,"byte_end":35669,"line_start":1060,"line_end":1064,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Binary(BinaryExpr {","highlight_start":27,"highlight_end":56},{"text":"                        left: Box::new(left),","highlight_start":1,"highlight_end":46},{"text":"                        op: BinOp::Gt,","highlight_start":1,"highlight_end":39},{"text":"                        right: Box::new(right),","highlight_start":1,"highlight_end":48},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":35484,"byte_end":35484,"line_start":1060,"line_end":1060,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Binary(BinaryExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":35669,"byte_end":35669,"line_start":1064,"line_end":1064,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1060:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1060\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Binary(BinaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1061\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m1062\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         op: BinOp::Gt,\n\u001b[1m\u001b[96m1063\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m1064\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1060\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m1061\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m1062\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         op: BinOp::Gt,\n\u001b[1m\u001b[96m1063\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m1064\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":35947,"byte_end":36132,"line_start":1073,"line_end":1077,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Binary(BinaryExpr {","highlight_start":27,"highlight_end":56},{"text":"                        left: Box::new(left),","highlight_start":1,"highlight_end":46},{"text":"                        op: BinOp::Ge,","highlight_start":1,"highlight_end":39},{"text":"                        right: Box::new(right),","highlight_start":1,"highlight_end":48},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":35947,"byte_end":35947,"line_start":1073,"line_end":1073,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Binary(BinaryExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":36132,"byte_end":36132,"line_start":1077,"line_end":1077,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1073:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1073\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Binary(BinaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1074\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m1075\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         op: BinOp::Ge,\n\u001b[1m\u001b[96m1076\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m1077\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1073\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m1074\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         left: Box::new(left),\n\u001b[1m\u001b[96m1075\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         op: BinOp::Ge,\n\u001b[1m\u001b[96m1076\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         right: Box::new(right),\n\u001b[1m\u001b[96m1077\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":36607,"byte_end":36777,"line_start":1093,"line_end":1097,"column_start":23,"column_end":19,"is_primary":true,"text":[{"text":"                kind: ExprKind::Binary(BinaryExpr {","highlight_start":23,"highlight_end":52},{"text":"                    left: Box::new(left),","highlight_start":1,"highlight_end":42},{"text":"                    op: BinOp::Shl,","highlight_start":1,"highlight_end":36},{"text":"                    right: Box::new(right),","highlight_start":1,"highlight_end":44},{"text":"                }),","highlight_start":1,"highlight_end":19}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":36607,"byte_end":36607,"line_start":1093,"line_end":1093,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                kind: ExprKind::Binary(BinaryExpr {","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":36777,"byte_end":36777,"line_start":1097,"line_end":1097,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"                }),","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1093:23\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1093\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                   kind: ExprKind::Binary(BinaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________^\u001b[0m\n\u001b[1m\u001b[96m1094\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     left: Box::new(left),\n\u001b[1m\u001b[96m1095\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     op: BinOp::Shl,\n\u001b[1m\u001b[96m1096\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     right: Box::new(right),\n\u001b[1m\u001b[96m1097\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1093\u001b[0m \u001b[92m~ \u001b[0m                kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m1094\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     left: Box::new(left),\n\u001b[1m\u001b[96m1095\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     op: BinOp::Shl,\n\u001b[1m\u001b[96m1096\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     right: Box::new(right),\n\u001b[1m\u001b[96m1097\u001b[0m \u001b[92m~ \u001b[0m                })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":37296,"byte_end":37498,"line_start":1115,"line_end":1119,"column_start":31,"column_end":27,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Binary(BinaryExpr {","highlight_start":31,"highlight_end":60},{"text":"                            left: Box::new(left),","highlight_start":1,"highlight_end":50},{"text":"                            op: BinOp::Add,","highlight_start":1,"highlight_end":44},{"text":"                            right: Box::new(right),","highlight_start":1,"highlight_end":52},{"text":"                        }),","highlight_start":1,"highlight_end":27}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":37296,"byte_end":37296,"line_start":1115,"line_end":1115,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Binary(BinaryExpr {","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":37498,"byte_end":37498,"line_start":1119,"line_end":1119,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                        }),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1115:31\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1115\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                           kind: ExprKind::Binary(BinaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________________^\u001b[0m\n\u001b[1m\u001b[96m1116\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             left: Box::new(left),\n\u001b[1m\u001b[96m1117\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             op: BinOp::Add,\n\u001b[1m\u001b[96m1118\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             right: Box::new(right),\n\u001b[1m\u001b[96m1119\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1115\u001b[0m \u001b[92m~ \u001b[0m                        kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m1116\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             left: Box::new(left),\n\u001b[1m\u001b[96m1117\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             op: BinOp::Add,\n\u001b[1m\u001b[96m1118\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             right: Box::new(right),\n\u001b[1m\u001b[96m1119\u001b[0m \u001b[92m~ \u001b[0m                        })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":37827,"byte_end":38029,"line_start":1128,"line_end":1132,"column_start":31,"column_end":27,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Binary(BinaryExpr {","highlight_start":31,"highlight_end":60},{"text":"                            left: Box::new(left),","highlight_start":1,"highlight_end":50},{"text":"                            op: BinOp::Sub,","highlight_start":1,"highlight_end":44},{"text":"                            right: Box::new(right),","highlight_start":1,"highlight_end":52},{"text":"                        }),","highlight_start":1,"highlight_end":27}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":37827,"byte_end":37827,"line_start":1128,"line_end":1128,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Binary(BinaryExpr {","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":38029,"byte_end":38029,"line_start":1132,"line_end":1132,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                        }),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1128:31\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1128\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                           kind: ExprKind::Binary(BinaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________________^\u001b[0m\n\u001b[1m\u001b[96m1129\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             left: Box::new(left),\n\u001b[1m\u001b[96m1130\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             op: BinOp::Sub,\n\u001b[1m\u001b[96m1131\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             right: Box::new(right),\n\u001b[1m\u001b[96m1132\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1128\u001b[0m \u001b[92m~ \u001b[0m                        kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m1129\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             left: Box::new(left),\n\u001b[1m\u001b[96m1130\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             op: BinOp::Sub,\n\u001b[1m\u001b[96m1131\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             right: Box::new(right),\n\u001b[1m\u001b[96m1132\u001b[0m \u001b[92m~ \u001b[0m                        })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":38620,"byte_end":38822,"line_start":1153,"line_end":1157,"column_start":31,"column_end":27,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Binary(BinaryExpr {","highlight_start":31,"highlight_end":60},{"text":"                            left: Box::new(left),","highlight_start":1,"highlight_end":50},{"text":"                            op: BinOp::Mul,","highlight_start":1,"highlight_end":44},{"text":"                            right: Box::new(right),","highlight_start":1,"highlight_end":52},{"text":"                        }),","highlight_start":1,"highlight_end":27}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":38620,"byte_end":38620,"line_start":1153,"line_end":1153,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Binary(BinaryExpr {","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":38822,"byte_end":38822,"line_start":1157,"line_end":1157,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                        }),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1153:31\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1153\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                           kind: ExprKind::Binary(BinaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________________^\u001b[0m\n\u001b[1m\u001b[96m1154\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             left: Box::new(left),\n\u001b[1m\u001b[96m1155\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             op: BinOp::Mul,\n\u001b[1m\u001b[96m1156\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             right: Box::new(right),\n\u001b[1m\u001b[96m1157\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1153\u001b[0m \u001b[92m~ \u001b[0m                        kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m1154\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             left: Box::new(left),\n\u001b[1m\u001b[96m1155\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             op: BinOp::Mul,\n\u001b[1m\u001b[96m1156\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             right: Box::new(right),\n\u001b[1m\u001b[96m1157\u001b[0m \u001b[92m~ \u001b[0m                        })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":39142,"byte_end":39344,"line_start":1166,"line_end":1170,"column_start":31,"column_end":27,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Binary(BinaryExpr {","highlight_start":31,"highlight_end":60},{"text":"                            left: Box::new(left),","highlight_start":1,"highlight_end":50},{"text":"                            op: BinOp::Div,","highlight_start":1,"highlight_end":44},{"text":"                            right: Box::new(right),","highlight_start":1,"highlight_end":52},{"text":"                        }),","highlight_start":1,"highlight_end":27}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":39142,"byte_end":39142,"line_start":1166,"line_end":1166,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Binary(BinaryExpr {","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":39344,"byte_end":39344,"line_start":1170,"line_end":1170,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                        }),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1166:31\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1166\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                           kind: ExprKind::Binary(BinaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________________^\u001b[0m\n\u001b[1m\u001b[96m1167\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             left: Box::new(left),\n\u001b[1m\u001b[96m1168\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             op: BinOp::Div,\n\u001b[1m\u001b[96m1169\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             right: Box::new(right),\n\u001b[1m\u001b[96m1170\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1166\u001b[0m \u001b[92m~ \u001b[0m                        kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m1167\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             left: Box::new(left),\n\u001b[1m\u001b[96m1168\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             op: BinOp::Div,\n\u001b[1m\u001b[96m1169\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             right: Box::new(right),\n\u001b[1m\u001b[96m1170\u001b[0m \u001b[92m~ \u001b[0m                        })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":39666,"byte_end":39868,"line_start":1179,"line_end":1183,"column_start":31,"column_end":27,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Binary(BinaryExpr {","highlight_start":31,"highlight_end":60},{"text":"                            left: Box::new(left),","highlight_start":1,"highlight_end":50},{"text":"                            op: BinOp::Mod,","highlight_start":1,"highlight_end":44},{"text":"                            right: Box::new(right),","highlight_start":1,"highlight_end":52},{"text":"                        }),","highlight_start":1,"highlight_end":27}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":39666,"byte_end":39666,"line_start":1179,"line_end":1179,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Binary(BinaryExpr {","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":39868,"byte_end":39868,"line_start":1183,"line_end":1183,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                        }),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1179:31\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1179\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                           kind: ExprKind::Binary(BinaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________________^\u001b[0m\n\u001b[1m\u001b[96m1180\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             left: Box::new(left),\n\u001b[1m\u001b[96m1181\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             op: BinOp::Mod,\n\u001b[1m\u001b[96m1182\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             right: Box::new(right),\n\u001b[1m\u001b[96m1183\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1179\u001b[0m \u001b[92m~ \u001b[0m                        kind: \u001b[92mBox::new(\u001b[0mExprKind::Binary(BinaryExpr {\n\u001b[1m\u001b[96m1180\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             left: Box::new(left),\n\u001b[1m\u001b[96m1181\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             op: BinOp::Mod,\n\u001b[1m\u001b[96m1182\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             right: Box::new(right),\n\u001b[1m\u001b[96m1183\u001b[0m \u001b[92m~ \u001b[0m                        })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":40357,"byte_end":40492,"line_start":1201,"line_end":1204,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Unary(UnaryExpr {","highlight_start":27,"highlight_end":54},{"text":"                        op: UnOp::Neg,","highlight_start":1,"highlight_end":39},{"text":"                        expr: Box::new(expr),","highlight_start":1,"highlight_end":46},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":40357,"byte_end":40357,"line_start":1201,"line_end":1201,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Unary(UnaryExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":40492,"byte_end":40492,"line_start":1204,"line_end":1204,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1201:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1201\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Unary(UnaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1202\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         op: UnOp::Neg,\n\u001b[1m\u001b[96m1203\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         expr: Box::new(expr),\n\u001b[1m\u001b[96m1204\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1201\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Unary(UnaryExpr {\n\u001b[1m\u001b[96m1202\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         op: UnOp::Neg,\n\u001b[1m\u001b[96m1203\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         expr: Box::new(expr),\n\u001b[1m\u001b[96m1204\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":40770,"byte_end":40905,"line_start":1213,"line_end":1216,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Unary(UnaryExpr {","highlight_start":27,"highlight_end":54},{"text":"                        op: UnOp::Not,","highlight_start":1,"highlight_end":39},{"text":"                        expr: Box::new(expr),","highlight_start":1,"highlight_end":46},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":40770,"byte_end":40770,"line_start":1213,"line_end":1213,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Unary(UnaryExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":40905,"byte_end":40905,"line_start":1216,"line_end":1216,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1213:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1213\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Unary(UnaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1214\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         op: UnOp::Not,\n\u001b[1m\u001b[96m1215\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         expr: Box::new(expr),\n\u001b[1m\u001b[96m1216\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1213\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Unary(UnaryExpr {\n\u001b[1m\u001b[96m1214\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         op: UnOp::Not,\n\u001b[1m\u001b[96m1215\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         expr: Box::new(expr),\n\u001b[1m\u001b[96m1216\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":41450,"byte_end":41648,"line_start":1231,"line_end":1234,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Unary(UnaryExpr {","highlight_start":27,"highlight_end":54},{"text":"                        op: if mutability == Mutability::Mutable { UnOp::RefMut } else { UnOp::Ref },","highlight_start":1,"highlight_end":102},{"text":"                        expr: Box::new(expr),","highlight_start":1,"highlight_end":46},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":41450,"byte_end":41450,"line_start":1231,"line_end":1231,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Unary(UnaryExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":41648,"byte_end":41648,"line_start":1234,"line_end":1234,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1231:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1231\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Unary(UnaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1232\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         op: if mutability == Mutability::Mutable { UnOp::RefMut } else { UnOp::Ref },\n\u001b[1m\u001b[96m1233\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         expr: Box::new(expr),\n\u001b[1m\u001b[96m1234\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1231\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Unary(UnaryExpr {\n\u001b[1m\u001b[96m1232\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         op: if mutability == Mutability::Mutable { UnOp::RefMut } else { UnOp::Ref },\n\u001b[1m\u001b[96m1233\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         expr: Box::new(expr),\n\u001b[1m\u001b[96m1234\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":41926,"byte_end":42063,"line_start":1243,"line_end":1246,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Unary(UnaryExpr {","highlight_start":27,"highlight_end":54},{"text":"                        op: UnOp::Deref,","highlight_start":1,"highlight_end":41},{"text":"                        expr: Box::new(expr),","highlight_start":1,"highlight_end":46},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":41926,"byte_end":41926,"line_start":1243,"line_end":1243,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Unary(UnaryExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":42063,"byte_end":42063,"line_start":1246,"line_end":1246,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1243:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1243\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Unary(UnaryExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1244\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         op: UnOp::Deref,\n\u001b[1m\u001b[96m1245\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         expr: Box::new(expr),\n\u001b[1m\u001b[96m1246\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1243\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Unary(UnaryExpr {\n\u001b[1m\u001b[96m1244\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         op: UnOp::Deref,\n\u001b[1m\u001b[96m1245\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         expr: Box::new(expr),\n\u001b[1m\u001b[96m1246\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":42658,"byte_end":42827,"line_start":1265,"line_end":1268,"column_start":31,"column_end":27,"is_primary":true,"text":[{"text":"                        kind: ExprKind::FieldAccess(FieldAccessExpr {","highlight_start":31,"highlight_end":70},{"text":"                            expr: Box::new(expr),","highlight_start":1,"highlight_end":50},{"text":"                            field: Arc::from(field),","highlight_start":1,"highlight_end":53},{"text":"                        }),","highlight_start":1,"highlight_end":27}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":42658,"byte_end":42658,"line_start":1265,"line_end":1265,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"                        kind: ExprKind::FieldAccess(FieldAccessExpr {","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":42827,"byte_end":42827,"line_start":1268,"line_end":1268,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                        }),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1265:31\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1265\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                           kind: ExprKind::FieldAccess(FieldAccessExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________________^\u001b[0m\n\u001b[1m\u001b[96m1266\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             expr: Box::new(expr),\n\u001b[1m\u001b[96m1267\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             field: Arc::from(field),\n\u001b[1m\u001b[96m1268\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1265\u001b[0m \u001b[92m~ \u001b[0m                        kind: \u001b[92mBox::new(\u001b[0mExprKind::FieldAccess(FieldAccessExpr {\n\u001b[1m\u001b[96m1266\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             expr: Box::new(expr),\n\u001b[1m\u001b[96m1267\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             field: Arc::from(field),\n\u001b[1m\u001b[96m1268\u001b[0m \u001b[92m~ \u001b[0m                        })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type mismatch resolving `<[Box<Expr>; 4] as Array>::Item == Expr`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":43185,"byte_end":43189,"line_start":1277,"line_end":1277,"column_start":30,"column_end":34,"is_primary":true,"text":[{"text":"                        args.push(self.parse_expr()?);","highlight_start":30,"highlight_end":34}],"label":"expected `Expr`, found `Box<Expr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `chim_ast::Expr`\n   found struct `Box<chim_ast::Expr>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0271]\u001b[0m\u001b[1m\u001b[97m: type mismatch resolving `<[Box<Expr>; 4] as Array>::Item == Expr`\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1277:30\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1277\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         args.push(self.parse_expr()?);\n     \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Expr`, found `Box<Expr>`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `chim_ast::Expr`\n                found struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::Expr\u001b[1m\u001b[35m>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":43509,"byte_end":43645,"line_start":1284,"line_end":1287,"column_start":31,"column_end":27,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Call(CallExpr {","highlight_start":31,"highlight_end":56},{"text":"                            func: Box::new(expr),","highlight_start":1,"highlight_end":50},{"text":"                            args,","highlight_start":1,"highlight_end":34},{"text":"                        }),","highlight_start":1,"highlight_end":27}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":43509,"byte_end":43509,"line_start":1284,"line_end":1284,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Call(CallExpr {","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":43645,"byte_end":43645,"line_start":1287,"line_end":1287,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                        }),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1284:31\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1284\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                           kind: ExprKind::Call(CallExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________________^\u001b[0m\n\u001b[1m\u001b[96m1285\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             func: Box::new(expr),\n\u001b[1m\u001b[96m1286\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             args,\n\u001b[1m\u001b[96m1287\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1284\u001b[0m \u001b[92m~ \u001b[0m                        kind: \u001b[92mBox::new(\u001b[0mExprKind::Call(CallExpr {\n\u001b[1m\u001b[96m1285\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             func: Box::new(expr),\n\u001b[1m\u001b[96m1286\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             args,\n\u001b[1m\u001b[96m1287\u001b[0m \u001b[92m~ \u001b[0m                        })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":44013,"byte_end":44169,"line_start":1297,"line_end":1300,"column_start":31,"column_end":27,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Index(IndexExpr {","highlight_start":31,"highlight_end":58},{"text":"                            expr: Box::new(expr),","highlight_start":1,"highlight_end":50},{"text":"                            index: Box::new(index),","highlight_start":1,"highlight_end":52},{"text":"                        }),","highlight_start":1,"highlight_end":27}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":44013,"byte_end":44013,"line_start":1297,"line_end":1297,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Index(IndexExpr {","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":44169,"byte_end":44169,"line_start":1300,"line_end":1300,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                        }),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1297:31\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1297\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                           kind: ExprKind::Index(IndexExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________________^\u001b[0m\n\u001b[1m\u001b[96m1298\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             expr: Box::new(expr),\n\u001b[1m\u001b[96m1299\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             index: Box::new(index),\n\u001b[1m\u001b[96m1300\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1297\u001b[0m \u001b[92m~ \u001b[0m                        kind: \u001b[92mBox::new(\u001b[0mExprKind::Index(IndexExpr {\n\u001b[1m\u001b[96m1298\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             expr: Box::new(expr),\n\u001b[1m\u001b[96m1299\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             index: Box::new(index),\n\u001b[1m\u001b[96m1300\u001b[0m \u001b[92m~ \u001b[0m                        })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":44477,"byte_end":44611,"line_start":1309,"line_end":1312,"column_start":31,"column_end":27,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Cast(CastExpr {","highlight_start":31,"highlight_end":56},{"text":"                            expr: Box::new(expr),","highlight_start":1,"highlight_end":50},{"text":"                            ty,","highlight_start":1,"highlight_end":32},{"text":"                        }),","highlight_start":1,"highlight_end":27}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":44477,"byte_end":44477,"line_start":1309,"line_end":1309,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"                        kind: ExprKind::Cast(CastExpr {","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":44611,"byte_end":44611,"line_start":1312,"line_end":1312,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                        }),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1309:31\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1309\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                           kind: ExprKind::Cast(CastExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m _______________________________^\u001b[0m\n\u001b[1m\u001b[96m1310\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             expr: Box::new(expr),\n\u001b[1m\u001b[96m1311\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             ty,\n\u001b[1m\u001b[96m1312\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|__________________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1309\u001b[0m \u001b[92m~ \u001b[0m                        kind: \u001b[92mBox::new(\u001b[0mExprKind::Cast(CastExpr {\n\u001b[1m\u001b[96m1310\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             expr: Box::new(expr),\n\u001b[1m\u001b[96m1311\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                             ty,\n\u001b[1m\u001b[96m1312\u001b[0m \u001b[92m~ \u001b[0m                        })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `ChineseIdentifier` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45023,"byte_end":45040,"line_start":1328,"line_end":1328,"column_start":51,"column_end":68,"is_primary":true,"text":[{"text":"            Some(Token::Identifier) | Some(Token::ChineseIdentifier) => {","highlight_start":51,"highlight_end":68}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `ChineseIdentifier` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1328:51\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1328\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Identifier) | Some(Token::ChineseIdentifier) => {\n     \u001b[1m\u001b[96m|\u001b[0m                                                   \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Meter` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45362,"byte_end":45367,"line_start":1337,"line_end":1337,"column_start":44,"column_end":49,"is_primary":true,"text":[{"text":"            Some(Token::Int) | Some(Token::Meter) | Some(Token::Kilometer) | Some(Token::Centimeter)","highlight_start":44,"highlight_end":49}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Meter` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1337:44\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1337\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Int) | Some(Token::Meter) | Some(Token::Kilometer) | Some(Token::Centimeter)\n     \u001b[1m\u001b[96m|\u001b[0m                                            \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Kilometer` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45383,"byte_end":45392,"line_start":1337,"line_end":1337,"column_start":65,"column_end":74,"is_primary":true,"text":[{"text":"            Some(Token::Int) | Some(Token::Meter) | Some(Token::Kilometer) | Some(Token::Centimeter)","highlight_start":65,"highlight_end":74}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Kilometer` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1337:65\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1337\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Int) | Some(Token::Meter) | Some(Token::Kilometer) | Some(Token::Centimeter)\n     \u001b[1m\u001b[96m|\u001b[0m                                                                 \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Centimeter` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45408,"byte_end":45418,"line_start":1337,"line_end":1337,"column_start":90,"column_end":100,"is_primary":true,"text":[{"text":"            Some(Token::Int) | Some(Token::Meter) | Some(Token::Kilometer) | Some(Token::Centimeter)","highlight_start":90,"highlight_end":100}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Centimeter` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1337:90\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1337\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Int) | Some(Token::Meter) | Some(Token::Kilometer) | Some(Token::Centimeter)\n     \u001b[1m\u001b[96m|\u001b[0m                                                                                          \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Millimeter` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45446,"byte_end":45456,"line_start":1338,"line_end":1338,"column_start":27,"column_end":37,"is_primary":true,"text":[{"text":"            | Some(Token::Millimeter) | Some(Token::Kilogram) | Some(Token::Gram) | Some(Token::Second)","highlight_start":27,"highlight_end":37}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Millimeter` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1338:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1338\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             | Some(Token::Millimeter) | Some(Token::Kilogram) | Some(Token::Gram) | Some(Token::Second)\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Kilogram` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45472,"byte_end":45480,"line_start":1338,"line_end":1338,"column_start":53,"column_end":61,"is_primary":true,"text":[{"text":"            | Some(Token::Millimeter) | Some(Token::Kilogram) | Some(Token::Gram) | Some(Token::Second)","highlight_start":53,"highlight_end":61}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Kilogram` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1338:53\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1338\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             | Some(Token::Millimeter) | Some(Token::Kilogram) | Some(Token::Gram) | Some(Token::Second)\n     \u001b[1m\u001b[96m|\u001b[0m                                                     \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Gram` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45496,"byte_end":45500,"line_start":1338,"line_end":1338,"column_start":77,"column_end":81,"is_primary":true,"text":[{"text":"            | Some(Token::Millimeter) | Some(Token::Kilogram) | Some(Token::Gram) | Some(Token::Second)","highlight_start":77,"highlight_end":81}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Gram` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1338:77\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1338\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             | Some(Token::Millimeter) | Some(Token::Kilogram) | Some(Token::Gram) | Some(Token::Second)\n     \u001b[1m\u001b[96m|\u001b[0m                                                                             \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Second` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45516,"byte_end":45522,"line_start":1338,"line_end":1338,"column_start":97,"column_end":103,"is_primary":true,"text":[{"text":"            | Some(Token::Millimeter) | Some(Token::Kilogram) | Some(Token::Gram) | Some(Token::Second)","highlight_start":97,"highlight_end":103}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a variant with a similar name","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45516,"byte_end":45522,"line_start":1338,"line_end":1338,"column_start":97,"column_end":103,"is_primary":true,"text":[{"text":"            | Some(Token::Millimeter) | Some(Token::Kilogram) | Some(Token::Gram) | Some(Token::Second)","highlight_start":97,"highlight_end":103}],"label":null,"suggested_replacement":"Send","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Second` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1338:97\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1338\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             | Some(Token::Millimeter) | Some(Token::Kilogram) | Some(Token::Gram) | Some(Token::Second)\n     \u001b[1m\u001b[96m|\u001b[0m                                                                                                 \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a variant with a similar name\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1338\u001b[0m \u001b[91m- \u001b[0m            | Some(Token::Millimeter) | Some(Token::Kilogram) | Some(Token::Gram) | Some(Token::\u001b[91mSecond\u001b[0m)\n\u001b[1m\u001b[96m1338\u001b[0m \u001b[92m+ \u001b[0m            | Some(Token::Millimeter) | Some(Token::Kilogram) | Some(Token::Gram) | Some(Token::\u001b[92mSend\u001b[0m)\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Millisecond` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45550,"byte_end":45561,"line_start":1339,"line_end":1339,"column_start":27,"column_end":38,"is_primary":true,"text":[{"text":"            | Some(Token::Millisecond) => {","highlight_start":27,"highlight_end":38}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Millisecond` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1339:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1339\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             | Some(Token::Millisecond) => {\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Scientific` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":46027,"byte_end":46037,"line_start":1351,"line_end":1351,"column_start":46,"column_end":56,"is_primary":true,"text":[{"text":"            Some(Token::Float) | Some(Token::Scientific) | Some(Token::ScientificFloat) => {","highlight_start":46,"highlight_end":56}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Scientific` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1351:46\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1351\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Float) | Some(Token::Scientific) | Some(Token::ScientificFloat) => {\n     \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `ScientificFloat` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":46053,"byte_end":46068,"line_start":1351,"line_end":1351,"column_start":72,"column_end":87,"is_primary":true,"text":[{"text":"            Some(Token::Float) | Some(Token::Scientific) | Some(Token::ScientificFloat) => {","highlight_start":72,"highlight_end":87}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `ScientificFloat` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1351:72\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1351\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Float) | Some(Token::Scientific) | Some(Token::ScientificFloat) => {\n     \u001b[1m\u001b[96m|\u001b[0m                                                                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `如果` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":49146,"byte_end":49152,"line_start":1436,"line_end":1436,"column_start":43,"column_end":45,"is_primary":true,"text":[{"text":"            Some(Token::If) | Some(Token::如果) => {","highlight_start":43,"highlight_end":45}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `如果` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1436:43\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1436\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::If) | Some(Token::如果) => {\n     \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `匹配` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":50023,"byte_end":50029,"line_start":1459,"line_end":1459,"column_start":46,"column_end":48,"is_primary":true,"text":[{"text":"            Some(Token::Match) | Some(Token::匹配) => {","highlight_start":46,"highlight_end":48}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `匹配` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1459:46\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1459\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Match) | Some(Token::匹配) => {\n     \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45191,"byte_end":45228,"line_start":1332,"line_end":1332,"column_start":27,"column_end":64,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Identifier(Arc::from(name)),","highlight_start":27,"highlight_end":64}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45191,"byte_end":45191,"line_start":1332,"line_end":1332,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Identifier(Arc::from(name)),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45228,"byte_end":45228,"line_start":1332,"line_end":1332,"column_start":64,"column_end":64,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Identifier(Arc::from(name)),","highlight_start":64,"highlight_end":64}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1332:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1332\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     kind: ExprKind::Identifier(Arc::from(name)),\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1332\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Identifier(Arc::from(name))\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[92m+++++++++\u001b[0m                                     \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45732,"byte_end":45879,"line_start":1343,"line_end":1346,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Literal(Literal {","highlight_start":27,"highlight_end":54},{"text":"                        kind: LiteralKind::Int(value),","highlight_start":1,"highlight_end":55},{"text":"                        span: start_span,","highlight_start":1,"highlight_end":42},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45732,"byte_end":45732,"line_start":1343,"line_end":1343,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Literal(Literal {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":45879,"byte_end":45879,"line_start":1346,"line_end":1346,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1343:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1343\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Literal(Literal {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1344\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         kind: LiteralKind::Int(value),\n\u001b[1m\u001b[96m1345\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         span: start_span,\n\u001b[1m\u001b[96m1346\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1343\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Literal(Literal {\n\u001b[1m\u001b[96m1344\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         kind: LiteralKind::Int(value),\n\u001b[1m\u001b[96m1345\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         span: start_span,\n\u001b[1m\u001b[96m1346\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":46240,"byte_end":46389,"line_start":1355,"line_end":1358,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Literal(Literal {","highlight_start":27,"highlight_end":54},{"text":"                        kind: LiteralKind::Float(value),","highlight_start":1,"highlight_end":57},{"text":"                        span: start_span,","highlight_start":1,"highlight_end":42},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":46240,"byte_end":46240,"line_start":1355,"line_end":1355,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Literal(Literal {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":46389,"byte_end":46389,"line_start":1358,"line_end":1358,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1355:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1355\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Literal(Literal {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1356\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         kind: LiteralKind::Float(value),\n\u001b[1m\u001b[96m1357\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         span: start_span,\n\u001b[1m\u001b[96m1358\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1355\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Literal(Literal {\n\u001b[1m\u001b[96m1356\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         kind: LiteralKind::Float(value),\n\u001b[1m\u001b[96m1357\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         span: start_span,\n\u001b[1m\u001b[96m1358\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":46641,"byte_end":46790,"line_start":1366,"line_end":1369,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Literal(Literal {","highlight_start":27,"highlight_end":54},{"text":"                        kind: LiteralKind::String(text),","highlight_start":1,"highlight_end":57},{"text":"                        span: start_span,","highlight_start":1,"highlight_end":42},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":46641,"byte_end":46641,"line_start":1366,"line_end":1366,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Literal(Literal {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":46790,"byte_end":46790,"line_start":1369,"line_end":1369,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1366:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1366\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Literal(Literal {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1367\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         kind: LiteralKind::String(text),\n\u001b[1m\u001b[96m1368\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         span: start_span,\n\u001b[1m\u001b[96m1369\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1366\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Literal(Literal {\n\u001b[1m\u001b[96m1367\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         kind: LiteralKind::String(text),\n\u001b[1m\u001b[96m1368\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         span: start_span,\n\u001b[1m\u001b[96m1369\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":46980,"byte_end":47127,"line_start":1376,"line_end":1379,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Literal(Literal {","highlight_start":27,"highlight_end":54},{"text":"                        kind: LiteralKind::Bool(true),","highlight_start":1,"highlight_end":55},{"text":"                        span: start_span,","highlight_start":1,"highlight_end":42},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":46980,"byte_end":46980,"line_start":1376,"line_end":1376,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Literal(Literal {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":47127,"byte_end":47127,"line_start":1379,"line_end":1379,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1376:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1376\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Literal(Literal {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1377\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         kind: LiteralKind::Bool(true),\n\u001b[1m\u001b[96m1378\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         span: start_span,\n\u001b[1m\u001b[96m1379\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1376\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Literal(Literal {\n\u001b[1m\u001b[96m1377\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         kind: LiteralKind::Bool(true),\n\u001b[1m\u001b[96m1378\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         span: start_span,\n\u001b[1m\u001b[96m1379\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":47318,"byte_end":47466,"line_start":1386,"line_end":1389,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Literal(Literal {","highlight_start":27,"highlight_end":54},{"text":"                        kind: LiteralKind::Bool(false),","highlight_start":1,"highlight_end":56},{"text":"                        span: start_span,","highlight_start":1,"highlight_end":42},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":47318,"byte_end":47318,"line_start":1386,"line_end":1386,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Literal(Literal {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":47466,"byte_end":47466,"line_start":1389,"line_end":1389,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1386:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1386\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Literal(Literal {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1387\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         kind: LiteralKind::Bool(false),\n\u001b[1m\u001b[96m1388\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         span: start_span,\n\u001b[1m\u001b[96m1389\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1386\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Literal(Literal {\n\u001b[1m\u001b[96m1387\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         kind: LiteralKind::Bool(false),\n\u001b[1m\u001b[96m1388\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         span: start_span,\n\u001b[1m\u001b[96m1389\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":47656,"byte_end":47797,"line_start":1396,"line_end":1399,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Literal(Literal {","highlight_start":27,"highlight_end":54},{"text":"                        kind: LiteralKind::Unit,","highlight_start":1,"highlight_end":49},{"text":"                        span: start_span,","highlight_start":1,"highlight_end":42},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":47656,"byte_end":47656,"line_start":1396,"line_end":1396,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Literal(Literal {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":47797,"byte_end":47797,"line_start":1399,"line_end":1399,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1396:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1396\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Literal(Literal {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1397\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         kind: LiteralKind::Unit,\n\u001b[1m\u001b[96m1398\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         span: start_span,\n\u001b[1m\u001b[96m1399\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1396\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Literal(Literal {\n\u001b[1m\u001b[96m1397\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         kind: LiteralKind::Unit,\n\u001b[1m\u001b[96m1398\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         span: start_span,\n\u001b[1m\u001b[96m1399\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type mismatch resolving `<[Box<Expr>; 4] as Array>::Item == Expr`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":48275,"byte_end":48279,"line_start":1412,"line_end":1412,"column_start":30,"column_end":34,"is_primary":true,"text":[{"text":"                    elements.push(self.parse_expr()?);","highlight_start":30,"highlight_end":34}],"label":"expected `Expr`, found `Box<Expr>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `chim_ast::Expr`\n   found struct `Box<chim_ast::Expr>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0271]\u001b[0m\u001b[1m\u001b[97m: type mismatch resolving `<[Box<Expr>; 4] as Array>::Item == Expr`\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1412:30\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1412\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     elements.push(self.parse_expr()?);\n     \u001b[1m\u001b[96m|\u001b[0m                              \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Expr`, found `Box<Expr>`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `chim_ast::Expr`\n                found struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::Expr\u001b[1m\u001b[35m>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":48569,"byte_end":48608,"line_start":1419,"line_end":1419,"column_start":27,"column_end":66,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Array(ArrayExpr { elements }),","highlight_start":27,"highlight_end":66}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":48569,"byte_end":48569,"line_start":1419,"line_end":1419,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Array(ArrayExpr { elements }),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":48608,"byte_end":48608,"line_start":1419,"line_end":1419,"column_start":66,"column_end":66,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Array(ArrayExpr { elements }),","highlight_start":66,"highlight_end":66}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1419:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1419\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     kind: ExprKind::Array(ArrayExpr { elements }),\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1419\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Array(ArrayExpr { elements })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[92m+++++++++\u001b[0m                                       \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":48849,"byte_end":49001,"line_start":1427,"line_end":1431,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Block(BlockExpr {","highlight_start":27,"highlight_end":54},{"text":"                        label: None,","highlight_start":1,"highlight_end":37},{"text":"                        stmts,","highlight_start":1,"highlight_end":31},{"text":"                        ty: None,","highlight_start":1,"highlight_end":34},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":48849,"byte_end":48849,"line_start":1427,"line_end":1427,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Block(BlockExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":49001,"byte_end":49001,"line_start":1431,"line_end":1431,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1427:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1427\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Block(BlockExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1428\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         label: None,\n\u001b[1m\u001b[96m1429\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         stmts,\n\u001b[1m\u001b[96m1430\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         ty: None,\n\u001b[1m\u001b[96m1431\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1427\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Block(BlockExpr {\n\u001b[1m\u001b[96m1428\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         label: None,\n\u001b[1m\u001b[96m1429\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         stmts,\n\u001b[1m\u001b[96m1430\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         ty: None,\n\u001b[1m\u001b[96m1431\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":49701,"byte_end":49875,"line_start":1450,"line_end":1454,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::If(IfExpr {","highlight_start":27,"highlight_end":48},{"text":"                        condition: Box::new(condition),","highlight_start":1,"highlight_end":56},{"text":"                        then_branch,","highlight_start":1,"highlight_end":37},{"text":"                        else_branch,","highlight_start":1,"highlight_end":37},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":49701,"byte_end":49701,"line_start":1450,"line_end":1450,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::If(IfExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":49875,"byte_end":49875,"line_start":1454,"line_end":1454,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1450:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1450\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::If(IfExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1451\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         condition: Box::new(condition),\n\u001b[1m\u001b[96m1452\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         then_branch,\n\u001b[1m\u001b[96m1453\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         else_branch,\n\u001b[1m\u001b[96m1454\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1450\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::If(IfExpr {\n\u001b[1m\u001b[96m1451\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         condition: Box::new(condition),\n\u001b[1m\u001b[96m1452\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         then_branch,\n\u001b[1m\u001b[96m1453\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         else_branch,\n\u001b[1m\u001b[96m1454\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":51147,"byte_end":51273,"line_start":1485,"line_end":1488,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Match(MatchExpr {","highlight_start":27,"highlight_end":54},{"text":"                        expr: Box::new(expr),","highlight_start":1,"highlight_end":46},{"text":"                        arms,","highlight_start":1,"highlight_end":30},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":51147,"byte_end":51147,"line_start":1485,"line_end":1485,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Match(MatchExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":51273,"byte_end":51273,"line_start":1488,"line_end":1488,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1485:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1485\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Match(MatchExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1486\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         expr: Box::new(expr),\n\u001b[1m\u001b[96m1487\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         arms,\n\u001b[1m\u001b[96m1488\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1485\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Match(MatchExpr {\n\u001b[1m\u001b[96m1486\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         expr: Box::new(expr),\n\u001b[1m\u001b[96m1487\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         arms,\n\u001b[1m\u001b[96m1488\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":51632,"byte_end":51747,"line_start":1500,"line_end":1503,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Loop(LoopExpr {","highlight_start":27,"highlight_end":52},{"text":"                        label: None,","highlight_start":1,"highlight_end":37},{"text":"                        body,","highlight_start":1,"highlight_end":30},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":51632,"byte_end":51632,"line_start":1500,"line_end":1500,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Loop(LoopExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":51747,"byte_end":51747,"line_start":1503,"line_end":1503,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1500:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1500\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Loop(LoopExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1501\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         label: None,\n\u001b[1m\u001b[96m1502\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         body,\n\u001b[1m\u001b[96m1503\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1500\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Loop(LoopExpr {\n\u001b[1m\u001b[96m1501\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         label: None,\n\u001b[1m\u001b[96m1502\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         body,\n\u001b[1m\u001b[96m1503\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Bar` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":52119,"byte_end":52122,"line_start":1511,"line_end":1511,"column_start":73,"column_end":76,"is_primary":true,"text":[{"text":"                if self.tokens.peek().map(|t| &t.token) != Some(&Token::Bar) {","highlight_start":73,"highlight_end":76}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Bar` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1511:73\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1511\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 if self.tokens.peek().map(|t| &t.token) != Some(&Token::Bar) {\n     \u001b[1m\u001b[96m|\u001b[0m                                                                         \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":52691,"byte_end":52706,"line_start":1523,"line_end":1523,"column_start":39,"column_end":54,"is_primary":true,"text":[{"text":"                                kind: TypeKind::Infer,","highlight_start":39,"highlight_end":54}],"label":"expected `Box<TypeKind>`, found `TypeKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::TypeKind>`\n     found enum `chim_ast::TypeKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":52691,"byte_end":52691,"line_start":1523,"line_end":1523,"column_start":39,"column_end":39,"is_primary":true,"text":[{"text":"                                kind: TypeKind::Infer,","highlight_start":39,"highlight_end":39}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":52706,"byte_end":52706,"line_start":1523,"line_end":1523,"column_start":54,"column_end":54,"is_primary":true,"text":[{"text":"                                kind: TypeKind::Infer,","highlight_start":54,"highlight_end":54}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1523:39\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1523\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   kind: TypeKind::Infer,\n     \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<TypeKind>`, found `TypeKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::TypeKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::TypeKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1523\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                                kind: \u001b[92mBox::new(\u001b[0mTypeKind::Infer\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[92m+++++++++\u001b[0m               \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Bar` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":53256,"byte_end":53259,"line_start":1537,"line_end":1537,"column_start":36,"column_end":39,"is_primary":true,"text":[{"text":"                self.expect(Token::Bar)?;","highlight_start":36,"highlight_end":39}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Bar` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1537:36\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1537\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 self.expect(Token::Bar)?;\n     \u001b[1m\u001b[96m|\u001b[0m                                    \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":53372,"byte_end":53562,"line_start":1540,"line_end":1545,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Closure(ClosureExpr {","highlight_start":27,"highlight_end":58},{"text":"                        params,","highlight_start":1,"highlight_end":32},{"text":"                        body,","highlight_start":1,"highlight_end":30},{"text":"                        is_async: false,","highlight_start":1,"highlight_end":41},{"text":"                        is_move,","highlight_start":1,"highlight_end":33},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":53372,"byte_end":53372,"line_start":1540,"line_end":1540,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Closure(ClosureExpr {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":53562,"byte_end":53562,"line_start":1545,"line_end":1545,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1540:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1540\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: ExprKind::Closure(ClosureExpr {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1541\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         params,\n\u001b[1m\u001b[96m1542\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         body,\n\u001b[1m\u001b[96m1543\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         is_async: false,\n\u001b[1m\u001b[96m1544\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         is_move,\n\u001b[1m\u001b[96m1545\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1540\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Closure(ClosureExpr {\n\u001b[1m\u001b[96m1541\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         params,\n \u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m1544\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         is_move,\n\u001b[1m\u001b[96m1545\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":53975,"byte_end":53998,"line_start":1557,"line_end":1557,"column_start":27,"column_end":50,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Return(value),","highlight_start":27,"highlight_end":50}],"label":"expected `Box<ExprKind>`, found `ExprKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::ExprKind>`\n     found enum `chim_ast::ExprKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":53975,"byte_end":53975,"line_start":1557,"line_end":1557,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Return(value),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":53998,"byte_end":53998,"line_start":1557,"line_end":1557,"column_start":50,"column_end":50,"is_primary":true,"text":[{"text":"                    kind: ExprKind::Return(value),","highlight_start":50,"highlight_end":50}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1557:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1557\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     kind: ExprKind::Return(value),\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<ExprKind>`, found `ExprKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::ExprKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::ExprKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1557\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mExprKind::Return(value)\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[92m+++++++++\u001b[0m                       \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":54324,"byte_end":54359,"line_start":1567,"line_end":1567,"column_start":21,"column_end":56,"is_primary":true,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":21,"highlight_end":56}],"label":"expected `ChimError`, found `&ChimError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":54320,"byte_end":54323,"line_start":1567,"line_end":1567,"column_start":17,"column_end":20,"is_primary":false,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":17,"highlight_end":20}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`ChimError` does not implement `Clone`, so `&ChimError` was cloned instead","code":null,"level":"note","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":54324,"byte_end":54351,"line_start":1567,"line_end":1567,"column_start":21,"column_end":48,"is_primary":true,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":21,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the type constructed contains `&ChimError` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":54324,"byte_end":54359,"line_start":1567,"line_end":1567,"column_start":21,"column_end":56,"is_primary":false,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":21,"highlight_end":56}],"label":"this argument influences the type of `Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":54320,"byte_end":54360,"line_start":1567,"line_end":1567,"column_start":17,"column_end":57,"is_primary":true,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":17,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\result.rs","byte_start":21514,"byte_end":21517,"line_start":566,"line_end":566,"column_start":5,"column_end":8,"is_primary":true,"text":[{"text":"    Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),","highlight_start":5,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1567:21\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1567\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(self.errors.last().unwrap().clone())\n     \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `ChimError`, found `&ChimError`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: `ChimError` does not implement `Clone`, so `&ChimError` was cloned instead\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1567:21\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1567\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(self.errors.last().unwrap().clone())\n     \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `&ChimError` due to the type of the argument passed\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1567:17\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1567\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(self.errors.last().unwrap().clone())\n     \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96m^^^^\u001b[0m\u001b[1m\u001b[96m-----------------------------------\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[96mthis argument influences the type of `Err`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\result.rs:566:5\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m566\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n     \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[92m^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `ChineseIdentifier` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":54607,"byte_end":54624,"line_start":1576,"line_end":1576,"column_start":51,"column_end":68,"is_primary":true,"text":[{"text":"            Some(Token::Identifier) | Some(Token::ChineseIdentifier) => {","highlight_start":51,"highlight_end":68}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `ChineseIdentifier` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1576:51\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1576\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Identifier) | Some(Token::ChineseIdentifier) => {\n     \u001b[1m\u001b[96m|\u001b[0m                                                   \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Underscore` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":54876,"byte_end":54886,"line_start":1583,"line_end":1583,"column_start":25,"column_end":35,"is_primary":true,"text":[{"text":"            Some(Token::Underscore) => {","highlight_start":25,"highlight_end":35}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Underscore` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1583:25\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1583\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Underscore) => {\n     \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Fn` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":59467,"byte_end":59469,"line_start":1698,"line_end":1698,"column_start":25,"column_end":27,"is_primary":true,"text":[{"text":"            Some(Token::Fn) | Some(Token::Func) | Some(Token::Function) => {","highlight_start":25,"highlight_end":27}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Fn` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1698:25\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1698\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Fn) | Some(Token::Func) | Some(Token::Function) => {\n     \u001b[1m\u001b[96m|\u001b[0m                         \u001b[1m\u001b[91m^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Function` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":59505,"byte_end":59513,"line_start":1698,"line_end":1698,"column_start":63,"column_end":71,"is_primary":true,"text":[{"text":"            Some(Token::Fn) | Some(Token::Func) | Some(Token::Function) => {","highlight_start":63,"highlight_end":71}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `Function` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1698:63\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1698\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Fn) | Some(Token::Func) | Some(Token::Function) => {\n     \u001b[1m\u001b[96m|\u001b[0m                                                               \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":57171,"byte_end":57193,"line_start":1642,"line_end":1642,"column_start":27,"column_end":49,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Tuple(types),","highlight_start":27,"highlight_end":49}],"label":"expected `Box<TypeKind>`, found `TypeKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::TypeKind>`\n     found enum `chim_ast::TypeKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":57171,"byte_end":57171,"line_start":1642,"line_end":1642,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Tuple(types),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":57193,"byte_end":57193,"line_start":1642,"line_end":1642,"column_start":49,"column_end":49,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Tuple(types),","highlight_start":49,"highlight_end":49}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1642:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1642\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     kind: TypeKind::Tuple(types),\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<TypeKind>`, found `TypeKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::TypeKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::TypeKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1642\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mTypeKind::Tuple(types)\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[92m+++++++++\u001b[0m                      \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":57876,"byte_end":57881,"line_start":1656,"line_end":1656,"column_start":51,"column_end":56,"is_primary":true,"text":[{"text":"                            kind: TypeKind::Array(inner, size),","highlight_start":51,"highlight_end":56}],"label":"expected `Box<Type>`, found `Type`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":57860,"byte_end":57875,"line_start":1656,"line_end":1656,"column_start":35,"column_end":50,"is_primary":false,"text":[{"text":"                            kind: TypeKind::Array(inner, size),","highlight_start":35,"highlight_end":50}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::Type>`\n   found struct `chim_ast::Type`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"D:\\PROJECT\\chim\\crates\\chim-ast\\src\\lib.rs","byte_start":10512,"byte_end":10517,"line_start":539,"line_end":539,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"    Array(Box<Type>, usize),","highlight_start":5,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":57876,"byte_end":57876,"line_start":1656,"line_end":1656,"column_start":51,"column_end":51,"is_primary":true,"text":[{"text":"                            kind: TypeKind::Array(inner, size),","highlight_start":51,"highlight_end":51}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":57881,"byte_end":57881,"line_start":1656,"line_end":1656,"column_start":56,"column_end":56,"is_primary":true,"text":[{"text":"                            kind: TypeKind::Array(inner, size),","highlight_start":56,"highlight_end":56}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1656:51\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1656\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   kind: TypeKind::Array(inner, size),\n     \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[96m---------------\u001b[0m \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<Type>`, found `Type`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::Type\u001b[1m\u001b[35m>\u001b[0m`\n                found struct `chim_ast::Type`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n    \u001b[1m\u001b[96m--> \u001b[0mD:\\PROJECT\\chim\\crates\\chim-ast\\src\\lib.rs:539:5\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m539\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Array(Box<Type>, usize),\n     \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[92m^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1656\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                            kind: TypeKind::Array(\u001b[92mBox::new(\u001b[0minner\u001b[92m)\u001b[0m, size),\n     \u001b[1m\u001b[96m|\u001b[0m                                                   \u001b[92m+++++++++\u001b[0m     \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":57860,"byte_end":57888,"line_start":1656,"line_end":1656,"column_start":35,"column_end":63,"is_primary":true,"text":[{"text":"                            kind: TypeKind::Array(inner, size),","highlight_start":35,"highlight_end":63}],"label":"expected `Box<TypeKind>`, found `TypeKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::TypeKind>`\n     found enum `chim_ast::TypeKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":57860,"byte_end":57860,"line_start":1656,"line_end":1656,"column_start":35,"column_end":35,"is_primary":true,"text":[{"text":"                            kind: TypeKind::Array(inner, size),","highlight_start":35,"highlight_end":35}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":57888,"byte_end":57888,"line_start":1656,"line_end":1656,"column_start":63,"column_end":63,"is_primary":true,"text":[{"text":"                            kind: TypeKind::Array(inner, size),","highlight_start":63,"highlight_end":63}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1656:35\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1656\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   kind: TypeKind::Array(inner, size),\n     \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<TypeKind>`, found `TypeKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::TypeKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::TypeKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1656\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                            kind: \u001b[92mBox::new(\u001b[0mTypeKind::Array(inner, size)\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[92m+++++++++\u001b[0m                            \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":58103,"byte_end":58135,"line_start":1663,"line_end":1663,"column_start":27,"column_end":59,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Slice(Box::new(inner)),","highlight_start":27,"highlight_end":59}],"label":"expected `Box<TypeKind>`, found `TypeKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::TypeKind>`\n     found enum `chim_ast::TypeKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":58103,"byte_end":58103,"line_start":1663,"line_end":1663,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Slice(Box::new(inner)),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":58135,"byte_end":58135,"line_start":1663,"line_end":1663,"column_start":59,"column_end":59,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Slice(Box::new(inner)),","highlight_start":59,"highlight_end":59}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1663:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1663\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     kind: TypeKind::Slice(Box::new(inner)),\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<TypeKind>`, found `TypeKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::TypeKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::TypeKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1663\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mTypeKind::Slice(Box::new(inner))\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[92m+++++++++\u001b[0m                                \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":58376,"byte_end":58430,"line_start":1671,"line_end":1671,"column_start":27,"column_end":81,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Pointer(Box::new(ty), Mutability::Immutable),","highlight_start":27,"highlight_end":81}],"label":"expected `Box<TypeKind>`, found `TypeKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::TypeKind>`\n     found enum `chim_ast::TypeKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":58376,"byte_end":58376,"line_start":1671,"line_end":1671,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Pointer(Box::new(ty), Mutability::Immutable),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":58430,"byte_end":58430,"line_start":1671,"line_end":1671,"column_start":81,"column_end":81,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Pointer(Box::new(ty), Mutability::Immutable),","highlight_start":81,"highlight_end":81}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1671:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1671\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     kind: TypeKind::Pointer(Box::new(ty), Mutability::Immutable),\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<TypeKind>`, found `TypeKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::TypeKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::TypeKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1671\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mTypeKind::Pointer(Box::new(ty), Mutability::Immutable)\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[92m+++++++++\u001b[0m                                                      \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":59315,"byte_end":59370,"line_start":1694,"line_end":1694,"column_start":27,"column_end":82,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Reference(lifetime, Box::new(ty), mutability),","highlight_start":27,"highlight_end":82}],"label":"expected `Box<TypeKind>`, found `TypeKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::TypeKind>`\n     found enum `chim_ast::TypeKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":59315,"byte_end":59315,"line_start":1694,"line_end":1694,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Reference(lifetime, Box::new(ty), mutability),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":59370,"byte_end":59370,"line_start":1694,"line_end":1694,"column_start":82,"column_end":82,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Reference(lifetime, Box::new(ty), mutability),","highlight_start":82,"highlight_end":82}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1694:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1694\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     kind: TypeKind::Reference(lifetime, Box::new(ty), mutability),\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<TypeKind>`, found `TypeKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::TypeKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::TypeKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1694\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mTypeKind::Reference(lifetime, Box::new(ty), mutability)\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[92m+++++++++\u001b[0m                                                       \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":60482,"byte_end":60509,"line_start":1719,"line_end":1719,"column_start":35,"column_end":62,"is_primary":true,"text":[{"text":"                            kind: TypeKind::Tuple(Vec::new()),","highlight_start":35,"highlight_end":62}],"label":"expected `Box<TypeKind>`, found `TypeKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::TypeKind>`\n     found enum `chim_ast::TypeKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":60482,"byte_end":60482,"line_start":1719,"line_end":1719,"column_start":35,"column_end":35,"is_primary":true,"text":[{"text":"                            kind: TypeKind::Tuple(Vec::new()),","highlight_start":35,"highlight_end":35}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":60509,"byte_end":60509,"line_start":1719,"line_end":1719,"column_start":62,"column_end":62,"is_primary":true,"text":[{"text":"                            kind: TypeKind::Tuple(Vec::new()),","highlight_start":62,"highlight_end":62}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1719:35\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1719\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m                   kind: TypeKind::Tuple(Vec::new()),\n     \u001b[1m\u001b[96m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<TypeKind>`, found `TypeKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::TypeKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::TypeKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1719\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                            kind: \u001b[92mBox::new(\u001b[0mTypeKind::Tuple(Vec::new())\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[92m+++++++++\u001b[0m                           \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":60307,"byte_end":60649,"line_start":1716,"line_end":1723,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Function(FunctionType {","highlight_start":27,"highlight_end":60},{"text":"                        params,","highlight_start":1,"highlight_end":32},{"text":"                        return_type: Box::new(return_type.unwrap_or(Type {","highlight_start":1,"highlight_end":75},{"text":"                            kind: TypeKind::Tuple(Vec::new()),","highlight_start":1,"highlight_end":63},{"text":"                            span: start_span,","highlight_start":1,"highlight_end":46},{"text":"                        })),","highlight_start":1,"highlight_end":29},{"text":"                        is_async: false,","highlight_start":1,"highlight_end":41},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<TypeKind>`, found `TypeKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::TypeKind>`\n     found enum `chim_ast::TypeKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":60307,"byte_end":60307,"line_start":1716,"line_end":1716,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Function(FunctionType {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":60649,"byte_end":60649,"line_start":1723,"line_end":1723,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1716:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1716\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: TypeKind::Function(FunctionType {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1717\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         params,\n\u001b[1m\u001b[96m1718\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         return_type: Box::new(return_type.unwrap_or(Type {\n\u001b[1m\u001b[96m1719\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             kind: TypeKind::Tuple(Vec::new()),\n\u001b[1m\u001b[96m...\u001b[0m    \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m1722\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         is_async: false,\n\u001b[1m\u001b[96m1723\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<TypeKind>`, found `TypeKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::TypeKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::TypeKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1716\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mTypeKind::Function(FunctionType {\n\u001b[1m\u001b[96m1717\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         params,\n \u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m1722\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         is_async: false,\n\u001b[1m\u001b[96m1723\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":60901,"byte_end":61212,"line_start":1731,"line_end":1738,"column_start":27,"column_end":23,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Path(Path {","highlight_start":27,"highlight_end":48},{"text":"                        segments: vec![PathSegment {","highlight_start":1,"highlight_end":53},{"text":"                            ident: Arc::from(name),","highlight_start":1,"highlight_end":52},{"text":"                            args: Vec::new(),","highlight_start":1,"highlight_end":46},{"text":"                            span: start_span,","highlight_start":1,"highlight_end":46},{"text":"                        }],","highlight_start":1,"highlight_end":28},{"text":"                        span: start_span,","highlight_start":1,"highlight_end":42},{"text":"                    }),","highlight_start":1,"highlight_end":23}],"label":"expected `Box<TypeKind>`, found `TypeKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::TypeKind>`\n     found enum `chim_ast::TypeKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":60901,"byte_end":60901,"line_start":1731,"line_end":1731,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Path(Path {","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":61212,"byte_end":61212,"line_start":1738,"line_end":1738,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                    }),","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1731:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1731\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                       kind: TypeKind::Path(Path {\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m ___________________________^\u001b[0m\n\u001b[1m\u001b[96m1732\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         segments: vec![PathSegment {\n\u001b[1m\u001b[96m1733\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             ident: Arc::from(name),\n\u001b[1m\u001b[96m1734\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                             args: Vec::new(),\n\u001b[1m\u001b[96m...\u001b[0m    \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[96m1737\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                         span: start_span,\n\u001b[1m\u001b[96m1738\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     }),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|______________________^\u001b[0m \u001b[1m\u001b[91mexpected `Box<TypeKind>`, found `TypeKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::TypeKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::TypeKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1731\u001b[0m \u001b[92m~ \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mTypeKind::Path(Path {\n\u001b[1m\u001b[96m1732\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         segments: vec![PathSegment {\n \u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m1737\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         span: start_span,\n\u001b[1m\u001b[96m1738\u001b[0m \u001b[92m~ \u001b[0m                    })\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":61403,"byte_end":61423,"line_start":1745,"line_end":1745,"column_start":27,"column_end":47,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Path(path),","highlight_start":27,"highlight_end":47}],"label":"expected `Box<TypeKind>`, found `TypeKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<chim_ast::TypeKind>`\n     found enum `chim_ast::TypeKind`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"store this in the heap by calling `Box::new`","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":61403,"byte_end":61403,"line_start":1745,"line_end":1745,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Path(path),","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":61423,"byte_end":61423,"line_start":1745,"line_end":1745,"column_start":47,"column_end":47,"is_primary":true,"text":[{"text":"                    kind: TypeKind::Path(path),","highlight_start":47,"highlight_end":47}],"label":null,"suggested_replacement":")","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1745:27\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1745\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                     kind: TypeKind::Path(path),\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<TypeKind>`, found `TypeKind`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<\u001b[0mchim_ast::TypeKind\u001b[1m\u001b[35m>\u001b[0m`\n                  found enum `chim_ast::TypeKind`\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n\u001b[1m\u001b[96mhelp\u001b[0m: store this in the heap by calling `Box::new`\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1745\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                    kind: \u001b[92mBox::new(\u001b[0mTypeKind::Path(path)\u001b[92m)\u001b[0m,\n     \u001b[1m\u001b[96m|\u001b[0m                           \u001b[92m+++++++++\u001b[0m                    \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `LAngle` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":62593,"byte_end":62599,"line_start":1786,"line_end":1786,"column_start":64,"column_end":70,"is_primary":true,"text":[{"text":"        if self.tokens.peek().map(|t| &t.token) != Some(Token::LAngle) {","highlight_start":64,"highlight_end":70}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `LAngle` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1786:64\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1786\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if self.tokens.peek().map(|t| &t.token) != Some(Token::LAngle) {\n     \u001b[1m\u001b[96m|\u001b[0m                                                                \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `RAngle` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":62783,"byte_end":62789,"line_start":1792,"line_end":1792,"column_start":67,"column_end":73,"is_primary":true,"text":[{"text":"        while self.tokens.peek().map(|t| &t.token) != Some(Token::RAngle) {","highlight_start":67,"highlight_end":73}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `RAngle` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1792:67\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1792\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while self.tokens.peek().map(|t| &t.token) != Some(Token::RAngle) {\n     \u001b[1m\u001b[96m|\u001b[0m                                                                   \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":63217,"byte_end":63229,"line_start":1801,"line_end":1801,"column_start":61,"column_end":73,"is_primary":true,"text":[{"text":"            if self.tokens.peek().map(|t| &t.token) == Some(Token::Comma) {","highlight_start":61,"highlight_end":73}],"label":"expected `&Token`, found `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":63212,"byte_end":63216,"line_start":1801,"line_end":1801,"column_start":56,"column_end":60,"is_primary":false,"text":[{"text":"            if self.tokens.peek().map(|t| &t.token) == Some(Token::Comma) {","highlight_start":56,"highlight_end":60}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `Token` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":63217,"byte_end":63229,"line_start":1801,"line_end":1801,"column_start":61,"column_end":73,"is_primary":false,"text":[{"text":"            if self.tokens.peek().map(|t| &t.token) == Some(Token::Comma) {","highlight_start":61,"highlight_end":73}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":63212,"byte_end":63230,"line_start":1801,"line_end":1801,"column_start":56,"column_end":74,"is_primary":true,"text":[{"text":"            if self.tokens.peek().map(|t| &t.token) == Some(Token::Comma) {","highlight_start":56,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider borrowing here","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":63217,"byte_end":63217,"line_start":1801,"line_end":1801,"column_start":61,"column_end":61,"is_primary":true,"text":[{"text":"            if self.tokens.peek().map(|t| &t.token) == Some(Token::Comma) {","highlight_start":61,"highlight_end":61}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1801:61\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1801\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             if self.tokens.peek().map(|t| &t.token) == Some(Token::Comma) {\n     \u001b[1m\u001b[96m|\u001b[0m                                                        \u001b[1m\u001b[96m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Token`, found `Token`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                        \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                        \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `Token` due to the type of the argument passed\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1801:56\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1801\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             if self.tokens.peek().map(|t| &t.token) == Some(Token::Comma) {\n     \u001b[1m\u001b[96m|\u001b[0m                                                        \u001b[1m\u001b[96m^^^^^\u001b[0m\u001b[1m\u001b[96m------------\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                             \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                             \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs:607:5\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m607\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n     \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider borrowing here\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1801\u001b[0m \u001b[1m\u001b[96m| \u001b[0m            if self.tokens.peek().map(|t| &t.token) == Some(\u001b[92m&\u001b[0mToken::Comma) {\n     \u001b[1m\u001b[96m|\u001b[0m                                                             \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `RAngle` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":63321,"byte_end":63327,"line_start":1806,"line_end":1806,"column_start":28,"column_end":34,"is_primary":true,"text":[{"text":"        self.expect(Token::RAngle)?;","highlight_start":28,"highlight_end":34}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `RAngle` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1806:28\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1806\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         self.expect(Token::RAngle)?;\n     \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":63495,"byte_end":63507,"line_start":1811,"line_end":1811,"column_start":57,"column_end":69,"is_primary":true,"text":[{"text":"        if self.tokens.peek().map(|t| &t.token) != Some(Token::Where) {","highlight_start":57,"highlight_end":69}],"label":"expected `&Token`, found `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":63490,"byte_end":63494,"line_start":1811,"line_end":1811,"column_start":52,"column_end":56,"is_primary":false,"text":[{"text":"        if self.tokens.peek().map(|t| &t.token) != Some(Token::Where) {","highlight_start":52,"highlight_end":56}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `Token` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":63495,"byte_end":63507,"line_start":1811,"line_end":1811,"column_start":57,"column_end":69,"is_primary":false,"text":[{"text":"        if self.tokens.peek().map(|t| &t.token) != Some(Token::Where) {","highlight_start":57,"highlight_end":69}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":63490,"byte_end":63508,"line_start":1811,"line_end":1811,"column_start":52,"column_end":70,"is_primary":true,"text":[{"text":"        if self.tokens.peek().map(|t| &t.token) != Some(Token::Where) {","highlight_start":52,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider borrowing here","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":63495,"byte_end":63495,"line_start":1811,"line_end":1811,"column_start":57,"column_end":57,"is_primary":true,"text":[{"text":"        if self.tokens.peek().map(|t| &t.token) != Some(Token::Where) {","highlight_start":57,"highlight_end":57}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1811:57\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1811\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if self.tokens.peek().map(|t| &t.token) != Some(Token::Where) {\n     \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[96m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Token`, found `Token`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `Token` due to the type of the argument passed\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1811:52\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1811\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if self.tokens.peek().map(|t| &t.token) != Some(Token::Where) {\n     \u001b[1m\u001b[96m|\u001b[0m                                                    \u001b[1m\u001b[96m^^^^^\u001b[0m\u001b[1m\u001b[96m------------\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                         \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                         \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs:607:5\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m607\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n     \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider borrowing here\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1811\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        if self.tokens.peek().map(|t| &t.token) != Some(\u001b[92m&\u001b[0mToken::Where) {\n     \u001b[1m\u001b[96m|\u001b[0m                                                         \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64015,"byte_end":64027,"line_start":1824,"line_end":1824,"column_start":61,"column_end":73,"is_primary":true,"text":[{"text":"            if self.tokens.peek().map(|t| &t.token) == Some(Token::Comma) {","highlight_start":61,"highlight_end":73}],"label":"expected `&Token`, found `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64010,"byte_end":64014,"line_start":1824,"line_end":1824,"column_start":56,"column_end":60,"is_primary":false,"text":[{"text":"            if self.tokens.peek().map(|t| &t.token) == Some(Token::Comma) {","highlight_start":56,"highlight_end":60}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `Token` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64015,"byte_end":64027,"line_start":1824,"line_end":1824,"column_start":61,"column_end":73,"is_primary":false,"text":[{"text":"            if self.tokens.peek().map(|t| &t.token) == Some(Token::Comma) {","highlight_start":61,"highlight_end":73}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64010,"byte_end":64028,"line_start":1824,"line_end":1824,"column_start":56,"column_end":74,"is_primary":true,"text":[{"text":"            if self.tokens.peek().map(|t| &t.token) == Some(Token::Comma) {","highlight_start":56,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider borrowing here","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64015,"byte_end":64015,"line_start":1824,"line_end":1824,"column_start":61,"column_end":61,"is_primary":true,"text":[{"text":"            if self.tokens.peek().map(|t| &t.token) == Some(Token::Comma) {","highlight_start":61,"highlight_end":61}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1824:61\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1824\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             if self.tokens.peek().map(|t| &t.token) == Some(Token::Comma) {\n     \u001b[1m\u001b[96m|\u001b[0m                                                        \u001b[1m\u001b[96m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Token`, found `Token`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                        \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                        \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `Token` due to the type of the argument passed\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1824:56\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1824\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             if self.tokens.peek().map(|t| &t.token) == Some(Token::Comma) {\n     \u001b[1m\u001b[96m|\u001b[0m                                                        \u001b[1m\u001b[96m^^^^^\u001b[0m\u001b[1m\u001b[96m------------\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                             \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                             \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs:607:5\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m607\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n     \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider borrowing here\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1824\u001b[0m \u001b[1m\u001b[96m| \u001b[0m            if self.tokens.peek().map(|t| &t.token) == Some(\u001b[92m&\u001b[0mToken::Comma) {\n     \u001b[1m\u001b[96m|\u001b[0m                                                             \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64388,"byte_end":64401,"line_start":1838,"line_end":1838,"column_start":60,"column_end":73,"is_primary":true,"text":[{"text":"        while self.tokens.peek().map(|t| &t.token) != Some(Token::LBrace)","highlight_start":60,"highlight_end":73}],"label":"expected `&Token`, found `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64383,"byte_end":64387,"line_start":1838,"line_end":1838,"column_start":55,"column_end":59,"is_primary":false,"text":[{"text":"        while self.tokens.peek().map(|t| &t.token) != Some(Token::LBrace)","highlight_start":55,"highlight_end":59}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `Token` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64388,"byte_end":64401,"line_start":1838,"line_end":1838,"column_start":60,"column_end":73,"is_primary":false,"text":[{"text":"        while self.tokens.peek().map(|t| &t.token) != Some(Token::LBrace)","highlight_start":60,"highlight_end":73}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64383,"byte_end":64402,"line_start":1838,"line_end":1838,"column_start":55,"column_end":74,"is_primary":true,"text":[{"text":"        while self.tokens.peek().map(|t| &t.token) != Some(Token::LBrace)","highlight_start":55,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider borrowing here","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64388,"byte_end":64388,"line_start":1838,"line_end":1838,"column_start":60,"column_end":60,"is_primary":true,"text":[{"text":"        while self.tokens.peek().map(|t| &t.token) != Some(Token::LBrace)","highlight_start":60,"highlight_end":60}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1838:60\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1838\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while self.tokens.peek().map(|t| &t.token) != Some(Token::LBrace)\n     \u001b[1m\u001b[96m|\u001b[0m                                                       \u001b[1m\u001b[96m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Token`, found `Token`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                       \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                       \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `Token` due to the type of the argument passed\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1838:55\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1838\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         while self.tokens.peek().map(|t| &t.token) != Some(Token::LBrace)\n     \u001b[1m\u001b[96m|\u001b[0m                                                       \u001b[1m\u001b[96m^^^^^\u001b[0m\u001b[1m\u001b[96m-------------\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                            \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                            \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs:607:5\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m607\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n     \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider borrowing here\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1838\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        while self.tokens.peek().map(|t| &t.token) != Some(\u001b[92m&\u001b[0mToken::LBrace)\n     \u001b[1m\u001b[96m|\u001b[0m                                                            \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64463,"byte_end":64475,"line_start":1839,"line_end":1839,"column_start":61,"column_end":73,"is_primary":true,"text":[{"text":"            && self.tokens.peek().map(|t| &t.token) != Some(Token::Where)","highlight_start":61,"highlight_end":73}],"label":"expected `&Token`, found `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64458,"byte_end":64462,"line_start":1839,"line_end":1839,"column_start":56,"column_end":60,"is_primary":false,"text":[{"text":"            && self.tokens.peek().map(|t| &t.token) != Some(Token::Where)","highlight_start":56,"highlight_end":60}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `Token` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64463,"byte_end":64475,"line_start":1839,"line_end":1839,"column_start":61,"column_end":73,"is_primary":false,"text":[{"text":"            && self.tokens.peek().map(|t| &t.token) != Some(Token::Where)","highlight_start":61,"highlight_end":73}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64458,"byte_end":64476,"line_start":1839,"line_end":1839,"column_start":56,"column_end":74,"is_primary":true,"text":[{"text":"            && self.tokens.peek().map(|t| &t.token) != Some(Token::Where)","highlight_start":56,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs","byte_start":24322,"byte_end":24326,"line_start":607,"line_end":607,"column_start":5,"column_end":9,"is_primary":true,"text":[{"text":"    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),","highlight_start":5,"highlight_end":9}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider borrowing here","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64463,"byte_end":64463,"line_start":1839,"line_end":1839,"column_start":61,"column_end":61,"is_primary":true,"text":[{"text":"            && self.tokens.peek().map(|t| &t.token) != Some(Token::Where)","highlight_start":61,"highlight_end":61}],"label":null,"suggested_replacement":"&","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1839:61\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1839\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             && self.tokens.peek().map(|t| &t.token) != Some(Token::Where)\n     \u001b[1m\u001b[96m|\u001b[0m                                                        \u001b[1m\u001b[96m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `&Token`, found `Token`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                        \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                        \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `Token` due to the type of the argument passed\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1839:56\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1839\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             && self.tokens.peek().map(|t| &t.token) != Some(Token::Where)\n     \u001b[1m\u001b[96m|\u001b[0m                                                        \u001b[1m\u001b[96m^^^^^\u001b[0m\u001b[1m\u001b[96m------------\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                             \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                                                             \u001b[1m\u001b[96mthis argument influences the type of `Some`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\option.rs:607:5\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m607\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n     \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider borrowing here\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1839\u001b[0m \u001b[1m\u001b[96m| \u001b[0m            && self.tokens.peek().map(|t| &t.token) != Some(\u001b[92m&\u001b[0mToken::Where)\n     \u001b[1m\u001b[96m|\u001b[0m                                                             \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `公有的` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64820,"byte_end":64829,"line_start":1850,"line_end":1850,"column_start":44,"column_end":47,"is_primary":true,"text":[{"text":"            Some(Token::Pub) | Some(Token::公有的) => {","highlight_start":44,"highlight_end":47}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `公有的` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1850:44\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1850\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Pub) | Some(Token::公有的) => {\n     \u001b[1m\u001b[96m|\u001b[0m                                            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `私有的` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":64955,"byte_end":64964,"line_start":1854,"line_end":1854,"column_start":45,"column_end":48,"is_primary":true,"text":[{"text":"            Some(Token::Priv) | Some(Token::私有的) => {","highlight_start":45,"highlight_end":48}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `私有的` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1854:45\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1854\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Priv) | Some(Token::私有的) => {\n     \u001b[1m\u001b[96m|\u001b[0m                                             \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `ChineseIdentifier` found for enum `Token` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":65261,"byte_end":65278,"line_start":1864,"line_end":1864,"column_start":51,"column_end":68,"is_primary":true,"text":[{"text":"            Some(Token::Identifier) | Some(Token::ChineseIdentifier) => Ok(self.intern_identifier()),","highlight_start":51,"highlight_end":68}],"label":"variant or associated item not found in `Token`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no variant or associated item named `ChineseIdentifier` found for enum `Token` in the current scope\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1864:51\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1864\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Some(Token::Identifier) | Some(Token::ChineseIdentifier) => Ok(self.intern_identifier()),\n     \u001b[1m\u001b[96m|\u001b[0m                                                   \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `Token`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":65547,"byte_end":65582,"line_start":1870,"line_end":1870,"column_start":21,"column_end":56,"is_primary":true,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":21,"highlight_end":56}],"label":"expected `ChimError`, found `&ChimError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":65543,"byte_end":65546,"line_start":1870,"line_end":1870,"column_start":17,"column_end":20,"is_primary":false,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":17,"highlight_end":20}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`ChimError` does not implement `Clone`, so `&ChimError` was cloned instead","code":null,"level":"note","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":65547,"byte_end":65574,"line_start":1870,"line_end":1870,"column_start":21,"column_end":48,"is_primary":true,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":21,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the type constructed contains `&ChimError` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":65547,"byte_end":65582,"line_start":1870,"line_end":1870,"column_start":21,"column_end":56,"is_primary":false,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":21,"highlight_end":56}],"label":"this argument influences the type of `Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":65543,"byte_end":65583,"line_start":1870,"line_end":1870,"column_start":17,"column_end":57,"is_primary":true,"text":[{"text":"                Err(self.errors.last().unwrap().clone())","highlight_start":17,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\result.rs","byte_start":21514,"byte_end":21517,"line_start":566,"line_end":566,"column_start":5,"column_end":8,"is_primary":true,"text":[{"text":"    Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),","highlight_start":5,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1870:21\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1870\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(self.errors.last().unwrap().clone())\n     \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `ChimError`, found `&ChimError`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: `ChimError` does not implement `Clone`, so `&ChimError` was cloned instead\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1870:21\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1870\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(self.errors.last().unwrap().clone())\n     \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `&ChimError` due to the type of the argument passed\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1870:17\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1870\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Err(self.errors.last().unwrap().clone())\n     \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96m^^^^\u001b[0m\u001b[1m\u001b[96m-----------------------------------\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m                     \u001b[1m\u001b[96mthis argument influences the type of `Err`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\result.rs:566:5\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m566\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n     \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[92m^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":66821,"byte_end":66856,"line_start":1913,"line_end":1913,"column_start":13,"column_end":48,"is_primary":true,"text":[{"text":"        Err(self.errors.last().unwrap().clone())","highlight_start":13,"highlight_end":48}],"label":"expected `ChimError`, found `&ChimError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":66817,"byte_end":66820,"line_start":1913,"line_end":1913,"column_start":9,"column_end":12,"is_primary":false,"text":[{"text":"        Err(self.errors.last().unwrap().clone())","highlight_start":9,"highlight_end":12}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`ChimError` does not implement `Clone`, so `&ChimError` was cloned instead","code":null,"level":"note","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":66821,"byte_end":66848,"line_start":1913,"line_end":1913,"column_start":13,"column_end":40,"is_primary":true,"text":[{"text":"        Err(self.errors.last().unwrap().clone())","highlight_start":13,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the type constructed contains `&ChimError` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":66821,"byte_end":66856,"line_start":1913,"line_end":1913,"column_start":13,"column_end":48,"is_primary":false,"text":[{"text":"        Err(self.errors.last().unwrap().clone())","highlight_start":13,"highlight_end":48}],"label":"this argument influences the type of `Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":66817,"byte_end":66857,"line_start":1913,"line_end":1913,"column_start":9,"column_end":49,"is_primary":true,"text":[{"text":"        Err(self.errors.last().unwrap().clone())","highlight_start":9,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\result.rs","byte_start":21514,"byte_end":21517,"line_start":566,"line_end":566,"column_start":5,"column_end":8,"is_primary":true,"text":[{"text":"    Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),","highlight_start":5,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1913:13\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1913\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Err(self.errors.last().unwrap().clone())\n     \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `ChimError`, found `&ChimError`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: `ChimError` does not implement `Clone`, so `&ChimError` was cloned instead\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1913:13\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1913\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Err(self.errors.last().unwrap().clone())\n     \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `&ChimError` due to the type of the argument passed\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1913:9\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1913\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Err(self.errors.last().unwrap().clone())\n     \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m^^^^\u001b[0m\u001b[1m\u001b[96m-----------------------------------\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96mthis argument influences the type of `Err`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n    \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Administrator\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\result.rs:566:5\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m566\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n     \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[92m^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":67102,"byte_end":67120,"line_start":1920,"line_end":1920,"column_start":22,"column_end":40,"is_primary":true,"text":[{"text":"                _ => self.tokens.next(),","highlight_start":22,"highlight_end":40}],"label":"expected `()`, found `Option<&SpannedToken>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":66901,"byte_end":67145,"line_start":1917,"line_end":1922,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        while !self.tokens.at_end() {","highlight_start":9,"highlight_end":38},{"text":"            match self.tokens.peek().map(|t| &t.token) {","highlight_start":1,"highlight_end":57},{"text":"                Some(Token::Semicolon) | Some(Token::LBrace) | Some(Token::RBrace) => break,","highlight_start":1,"highlight_end":93},{"text":"                _ => self.tokens.next(),","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":"expected this to be `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":66901,"byte_end":67145,"line_start":1917,"line_end":1922,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        while !self.tokens.at_end() {","highlight_start":9,"highlight_end":38},{"text":"            match self.tokens.peek().map(|t| &t.token) {","highlight_start":1,"highlight_end":57},{"text":"                Some(Token::Semicolon) | Some(Token::LBrace) | Some(Token::RBrace) => break,","highlight_start":1,"highlight_end":93},{"text":"                _ => self.tokens.next(),","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `while` loop","def_site_span":{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected unit type `()`\n        found enum `Option<&SpannedToken>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using a semicolon here","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":67135,"byte_end":67135,"line_start":1921,"line_end":1921,"column_start":14,"column_end":14,"is_primary":true,"text":[{"text":"            }","highlight_start":14,"highlight_end":14}],"label":null,"suggested_replacement":";","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"consider using a semicolon here","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":67145,"byte_end":67145,"line_start":1922,"line_end":1922,"column_start":10,"column_end":10,"is_primary":true,"text":[{"text":"        }","highlight_start":10,"highlight_end":10}],"label":null,"suggested_replacement":";","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":66901,"byte_end":67145,"line_start":1917,"line_end":1922,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        while !self.tokens.at_end() {","highlight_start":9,"highlight_end":38},{"text":"            match self.tokens.peek().map(|t| &t.token) {","highlight_start":1,"highlight_end":57},{"text":"                Some(Token::Semicolon) | Some(Token::LBrace) | Some(Token::RBrace) => break,","highlight_start":1,"highlight_end":93},{"text":"                _ => self.tokens.next(),","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `while` loop","def_site_span":{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1920:22\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1917\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m/\u001b[0m         while !self.tokens.at_end() {\n\u001b[1m\u001b[96m1918\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             match self.tokens.peek().map(|t| &t.token) {\n\u001b[1m\u001b[96m1919\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 Some(Token::Semicolon) | Some(Token::LBrace) | Some(Token::RBrace) => break,\n\u001b[1m\u001b[96m1920\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 _ => self.tokens.next(),\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `()`, found `Option<&SpannedToken>`\u001b[0m\n\u001b[1m\u001b[96m1921\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             }\n\u001b[1m\u001b[96m1922\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         }\n     \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|_________-\u001b[0m \u001b[1m\u001b[96mexpected this to be `()`\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n     \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected unit type `\u001b[1m\u001b[35m()\u001b[0m`\n                     found enum `\u001b[1m\u001b[35mOption<&SpannedToken>\u001b[0m`\n\u001b[1m\u001b[96mhelp\u001b[0m: consider using a semicolon here\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1921\u001b[0m \u001b[1m\u001b[96m| \u001b[0m            }\u001b[92m;\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m              \u001b[92m+\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider using a semicolon here\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1922\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        }\u001b[92m;\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m          \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 2 arguments but 3 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":67326,"byte_end":67339,"line_start":1928,"line_end":1928,"column_start":47,"column_end":60,"is_primary":false,"text":[{"text":"    let tokens = chim_lexer::tokenize(source, &mut interner, file_id);","highlight_start":47,"highlight_end":60}],"label":"unexpected argument #2","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":67297,"byte_end":67317,"line_start":1928,"line_end":1928,"column_start":18,"column_end":38,"is_primary":true,"text":[{"text":"    let tokens = chim_lexer::tokenize(source, &mut interner, file_id);","highlight_start":18,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"D:\\PROJECT\\chim\\crates\\chim-lexer\\src\\lib.rs","byte_start":17213,"byte_end":17221,"line_start":561,"line_end":561,"column_start":8,"column_end":16,"is_primary":true,"text":[{"text":"pub fn tokenize(source: &str, file_id: FileId) -> (Vec<SpannedToken>, Rodeo) {","highlight_start":8,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra argument","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":67324,"byte_end":67339,"line_start":1928,"line_end":1928,"column_start":45,"column_end":60,"is_primary":true,"text":[{"text":"    let tokens = chim_lexer::tokenize(source, &mut interner, file_id);","highlight_start":45,"highlight_end":60}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m\u001b[97m: this function takes 2 arguments but 3 arguments were supplied\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1928:18\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1928\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     let tokens = chim_lexer::tokenize(source, &mut interner, file_id);\n     \u001b[1m\u001b[96m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m         \u001b[1m\u001b[96m-------------\u001b[0m \u001b[1m\u001b[96munexpected argument #2\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n    \u001b[1m\u001b[96m--> \u001b[0mD:\\PROJECT\\chim\\crates\\chim-lexer\\src\\lib.rs:561:8\n     \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m561\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn tokenize(source: &str, file_id: FileId) -> (Vec<SpannedToken>, Rodeo) {\n     \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra argument\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1928\u001b[0m \u001b[91m- \u001b[0m    let tokens = chim_lexer::tokenize(source\u001b[91m, &mut interner\u001b[0m, file_id);\n\u001b[1m\u001b[96m1928\u001b[0m \u001b[92m+ \u001b[0m    let tokens = chim_lexer::tokenize(source, file_id);\n     \u001b[1m\u001b[96m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot move out of `start_span` because it is borrowed","code":{"code":"E0505","explanation":"A value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let _ref_to_val: &Value = &x;\n    eat(x);\n    borrow(_ref_to_val);\n}\n```\n\nHere, the function `eat` takes ownership of `x`. However,\n`x` cannot be moved because the borrow to `_ref_to_val`\nneeds to last till the function `borrow`.\nTo fix that you can do a few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    eat(&x); // pass by reference, if it's possible\n    borrow(ref_to_val);\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    borrow(ref_to_val);\n    // ref_to_val is no longer used.\n    eat(x);\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let ref_to_val: &Value = &x;\n    eat(x); // it will be copied here.\n    borrow(ref_to_val);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":3294,"byte_end":3304,"line_start":88,"line_end":88,"column_start":68,"column_end":78,"is_primary":true,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":68,"highlight_end":78}],"label":"move out of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":3246,"byte_end":3256,"line_start":88,"line_end":88,"column_start":20,"column_end":30,"is_primary":false,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":20,"highlight_end":30}],"label":"borrow of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":2849,"byte_end":2859,"line_start":78,"line_end":78,"column_start":13,"column_end":23,"is_primary":false,"text":[{"text":"        let start_span = self.current_span()?;","highlight_start":13,"highlight_end":23}],"label":"binding `start_span` declared here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":3257,"byte_end":3262,"line_start":88,"line_end":88,"column_start":31,"column_end":36,"is_primary":false,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":31,"highlight_end":36}],"label":"borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":3256,"byte_end":3256,"line_start":88,"line_end":88,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0505]\u001b[0m\u001b[1m\u001b[97m: cannot move out of `start_span` because it is borrowed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:88:68\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m78\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let start_span = self.current_span()?;\n   \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mbinding `start_span` declared here\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m88\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let span = start_span.merge(&self.current_span().unwrap_or(start_span));\n   \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[96mborrow later used by call\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmove out of `start_span` occurs here\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96mborrow of `start_span` occurs here\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m88\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        let span = start_span\u001b[92m.clone()\u001b[0m.merge(&self.current_span().unwrap_or(start_span));\n   \u001b[1m\u001b[96m|\u001b[0m                              \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot move out of `start_span` because it is borrowed","code":{"code":"E0505","explanation":"A value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let _ref_to_val: &Value = &x;\n    eat(x);\n    borrow(_ref_to_val);\n}\n```\n\nHere, the function `eat` takes ownership of `x`. However,\n`x` cannot be moved because the borrow to `_ref_to_val`\nneeds to last till the function `borrow`.\nTo fix that you can do a few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    eat(&x); // pass by reference, if it's possible\n    borrow(ref_to_val);\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    borrow(ref_to_val);\n    // ref_to_val is no longer used.\n    eat(x);\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let ref_to_val: &Value = &x;\n    eat(x); // it will be copied here.\n    borrow(ref_to_val);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":6870,"byte_end":6880,"line_start":207,"line_end":207,"column_start":68,"column_end":78,"is_primary":true,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":68,"highlight_end":78}],"label":"move out of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":6822,"byte_end":6832,"line_start":207,"line_end":207,"column_start":20,"column_end":30,"is_primary":false,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":20,"highlight_end":30}],"label":"borrow of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":6428,"byte_end":6438,"line_start":196,"line_end":196,"column_start":13,"column_end":23,"is_primary":false,"text":[{"text":"        let start_span = self.current_span()?;","highlight_start":13,"highlight_end":23}],"label":"binding `start_span` declared here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":6833,"byte_end":6838,"line_start":207,"line_end":207,"column_start":31,"column_end":36,"is_primary":false,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":31,"highlight_end":36}],"label":"borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":6832,"byte_end":6832,"line_start":207,"line_end":207,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0505]\u001b[0m\u001b[1m\u001b[97m: cannot move out of `start_span` because it is borrowed\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:207:68\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m196\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let start_span = self.current_span()?;\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mbinding `start_span` declared here\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m207\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let span = start_span.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[96mborrow later used by call\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmove out of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96mborrow of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m207\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        let span = start_span\u001b[92m.clone()\u001b[0m.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                              \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot move out of `start_span` because it is borrowed","code":{"code":"E0505","explanation":"A value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let _ref_to_val: &Value = &x;\n    eat(x);\n    borrow(_ref_to_val);\n}\n```\n\nHere, the function `eat` takes ownership of `x`. However,\n`x` cannot be moved because the borrow to `_ref_to_val`\nneeds to last till the function `borrow`.\nTo fix that you can do a few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    eat(&x); // pass by reference, if it's possible\n    borrow(ref_to_val);\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    borrow(ref_to_val);\n    // ref_to_val is no longer used.\n    eat(x);\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let ref_to_val: &Value = &x;\n    eat(x); // it will be copied here.\n    borrow(ref_to_val);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":7915,"byte_end":7925,"line_start":240,"line_end":240,"column_start":68,"column_end":78,"is_primary":true,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":68,"highlight_end":78}],"label":"move out of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":7867,"byte_end":7877,"line_start":240,"line_end":240,"column_start":20,"column_end":30,"is_primary":false,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":20,"highlight_end":30}],"label":"borrow of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":7112,"byte_end":7122,"line_start":220,"line_end":220,"column_start":13,"column_end":23,"is_primary":false,"text":[{"text":"        let start_span = self.current_span()?;","highlight_start":13,"highlight_end":23}],"label":"binding `start_span` declared here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":7878,"byte_end":7883,"line_start":240,"line_end":240,"column_start":31,"column_end":36,"is_primary":false,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":31,"highlight_end":36}],"label":"borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":7877,"byte_end":7877,"line_start":240,"line_end":240,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0505]\u001b[0m\u001b[1m\u001b[97m: cannot move out of `start_span` because it is borrowed\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:240:68\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m220\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let start_span = self.current_span()?;\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mbinding `start_span` declared here\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m240\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let span = start_span.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[96mborrow later used by call\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmove out of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96mborrow of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m240\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        let span = start_span\u001b[92m.clone()\u001b[0m.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                              \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot move out of `start_span` because it is borrowed","code":{"code":"E0505","explanation":"A value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let _ref_to_val: &Value = &x;\n    eat(x);\n    borrow(_ref_to_val);\n}\n```\n\nHere, the function `eat` takes ownership of `x`. However,\n`x` cannot be moved because the borrow to `_ref_to_val`\nneeds to last till the function `borrow`.\nTo fix that you can do a few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    eat(&x); // pass by reference, if it's possible\n    borrow(ref_to_val);\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    borrow(ref_to_val);\n    // ref_to_val is no longer used.\n    eat(x);\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let ref_to_val: &Value = &x;\n    eat(x); // it will be copied here.\n    borrow(ref_to_val);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":9781,"byte_end":9791,"line_start":302,"line_end":302,"column_start":68,"column_end":78,"is_primary":true,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":68,"highlight_end":78}],"label":"move out of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":9733,"byte_end":9743,"line_start":302,"line_end":302,"column_start":20,"column_end":30,"is_primary":false,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":20,"highlight_end":30}],"label":"borrow of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":9400,"byte_end":9410,"line_start":293,"line_end":293,"column_start":13,"column_end":23,"is_primary":false,"text":[{"text":"        let start_span = self.current_span()?;","highlight_start":13,"highlight_end":23}],"label":"binding `start_span` declared here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":9744,"byte_end":9749,"line_start":302,"line_end":302,"column_start":31,"column_end":36,"is_primary":false,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":31,"highlight_end":36}],"label":"borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":9743,"byte_end":9743,"line_start":302,"line_end":302,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0505]\u001b[0m\u001b[1m\u001b[97m: cannot move out of `start_span` because it is borrowed\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:302:68\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m293\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let start_span = self.current_span()?;\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mbinding `start_span` declared here\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m302\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let span = start_span.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[96mborrow later used by call\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmove out of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96mborrow of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m302\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        let span = start_span\u001b[92m.clone()\u001b[0m.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                              \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot move out of `start_span` because it is borrowed","code":{"code":"E0505","explanation":"A value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let _ref_to_val: &Value = &x;\n    eat(x);\n    borrow(_ref_to_val);\n}\n```\n\nHere, the function `eat` takes ownership of `x`. However,\n`x` cannot be moved because the borrow to `_ref_to_val`\nneeds to last till the function `borrow`.\nTo fix that you can do a few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    eat(&x); // pass by reference, if it's possible\n    borrow(ref_to_val);\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    borrow(ref_to_val);\n    // ref_to_val is no longer used.\n    eat(x);\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let ref_to_val: &Value = &x;\n    eat(x); // it will be copied here.\n    borrow(ref_to_val);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":10725,"byte_end":10735,"line_start":333,"line_end":333,"column_start":68,"column_end":78,"is_primary":true,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":68,"highlight_end":78}],"label":"move out of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":10677,"byte_end":10687,"line_start":333,"line_end":333,"column_start":20,"column_end":30,"is_primary":false,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":20,"highlight_end":30}],"label":"borrow of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":10079,"byte_end":10089,"line_start":316,"line_end":316,"column_start":13,"column_end":23,"is_primary":false,"text":[{"text":"        let start_span = self.current_span()?;","highlight_start":13,"highlight_end":23}],"label":"binding `start_span` declared here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":10688,"byte_end":10693,"line_start":333,"line_end":333,"column_start":31,"column_end":36,"is_primary":false,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":31,"highlight_end":36}],"label":"borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":10687,"byte_end":10687,"line_start":333,"line_end":333,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0505]\u001b[0m\u001b[1m\u001b[97m: cannot move out of `start_span` because it is borrowed\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:333:68\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m316\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let start_span = self.current_span()?;\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mbinding `start_span` declared here\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m333\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let span = start_span.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[96mborrow later used by call\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmove out of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96mborrow of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m333\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        let span = start_span\u001b[92m.clone()\u001b[0m.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                              \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot move out of `start_span` because it is borrowed","code":{"code":"E0505","explanation":"A value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let _ref_to_val: &Value = &x;\n    eat(x);\n    borrow(_ref_to_val);\n}\n```\n\nHere, the function `eat` takes ownership of `x`. However,\n`x` cannot be moved because the borrow to `_ref_to_val`\nneeds to last till the function `borrow`.\nTo fix that you can do a few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    eat(&x); // pass by reference, if it's possible\n    borrow(ref_to_val);\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    borrow(ref_to_val);\n    // ref_to_val is no longer used.\n    eat(x);\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let ref_to_val: &Value = &x;\n    eat(x); // it will be copied here.\n    borrow(ref_to_val);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":11798,"byte_end":11808,"line_start":365,"line_end":365,"column_start":76,"column_end":86,"is_primary":true,"text":[{"text":"                let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":76,"highlight_end":86}],"label":"move out of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":11750,"byte_end":11760,"line_start":365,"line_end":365,"column_start":28,"column_end":38,"is_primary":false,"text":[{"text":"                let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":28,"highlight_end":38}],"label":"borrow of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":11163,"byte_end":11173,"line_start":350,"line_end":350,"column_start":17,"column_end":27,"is_primary":false,"text":[{"text":"            let start_span = self.current_span()?;","highlight_start":17,"highlight_end":27}],"label":"binding `start_span` declared here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":11761,"byte_end":11766,"line_start":365,"line_end":365,"column_start":39,"column_end":44,"is_primary":false,"text":[{"text":"                let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":39,"highlight_end":44}],"label":"borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":11760,"byte_end":11760,"line_start":365,"line_end":365,"column_start":38,"column_end":38,"is_primary":true,"text":[{"text":"                let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":38,"highlight_end":38}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0505]\u001b[0m\u001b[1m\u001b[97m: cannot move out of `start_span` because it is borrowed\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:365:76\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m350\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let start_span = self.current_span()?;\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mbinding `start_span` declared here\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m365\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 let span = start_span.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[96mborrow later used by call\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmove out of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                            \u001b[1m\u001b[96mborrow of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m365\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                let span = start_span\u001b[92m.clone()\u001b[0m.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot move out of `start_span` because it is borrowed","code":{"code":"E0505","explanation":"A value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let _ref_to_val: &Value = &x;\n    eat(x);\n    borrow(_ref_to_val);\n}\n```\n\nHere, the function `eat` takes ownership of `x`. However,\n`x` cannot be moved because the borrow to `_ref_to_val`\nneeds to last till the function `borrow`.\nTo fix that you can do a few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    eat(&x); // pass by reference, if it's possible\n    borrow(ref_to_val);\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    borrow(ref_to_val);\n    // ref_to_val is no longer used.\n    eat(x);\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let ref_to_val: &Value = &x;\n    eat(x); // it will be copied here.\n    borrow(ref_to_val);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":13233,"byte_end":13243,"line_start":410,"line_end":410,"column_start":72,"column_end":82,"is_primary":true,"text":[{"text":"            let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":72,"highlight_end":82}],"label":"move out of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":13185,"byte_end":13195,"line_start":410,"line_end":410,"column_start":24,"column_end":34,"is_primary":false,"text":[{"text":"            let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":24,"highlight_end":34}],"label":"borrow of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":12901,"byte_end":12911,"line_start":403,"line_end":403,"column_start":17,"column_end":27,"is_primary":false,"text":[{"text":"            let start_span = self.current_span()?;","highlight_start":17,"highlight_end":27}],"label":"binding `start_span` declared here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":13196,"byte_end":13201,"line_start":410,"line_end":410,"column_start":35,"column_end":40,"is_primary":false,"text":[{"text":"            let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":35,"highlight_end":40}],"label":"borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":13195,"byte_end":13195,"line_start":410,"line_end":410,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"            let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0505]\u001b[0m\u001b[1m\u001b[97m: cannot move out of `start_span` because it is borrowed\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:410:72\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m403\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let start_span = self.current_span()?;\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mbinding `start_span` declared here\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m410\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let span = start_span.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[96mborrow later used by call\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmove out of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[96mborrow of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m410\u001b[0m \u001b[1m\u001b[96m| \u001b[0m            let span = start_span\u001b[92m.clone()\u001b[0m.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot move out of `start_span` because it is borrowed","code":{"code":"E0505","explanation":"A value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let _ref_to_val: &Value = &x;\n    eat(x);\n    borrow(_ref_to_val);\n}\n```\n\nHere, the function `eat` takes ownership of `x`. However,\n`x` cannot be moved because the borrow to `_ref_to_val`\nneeds to last till the function `borrow`.\nTo fix that you can do a few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    eat(&x); // pass by reference, if it's possible\n    borrow(ref_to_val);\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    borrow(ref_to_val);\n    // ref_to_val is no longer used.\n    eat(x);\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let ref_to_val: &Value = &x;\n    eat(x); // it will be copied here.\n    borrow(ref_to_val);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":14980,"byte_end":14990,"line_start":459,"line_end":459,"column_start":72,"column_end":82,"is_primary":true,"text":[{"text":"            let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":72,"highlight_end":82}],"label":"move out of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":14932,"byte_end":14942,"line_start":459,"line_end":459,"column_start":24,"column_end":34,"is_primary":false,"text":[{"text":"            let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":24,"highlight_end":34}],"label":"borrow of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":13790,"byte_end":13800,"line_start":430,"line_end":430,"column_start":17,"column_end":27,"is_primary":false,"text":[{"text":"            let start_span = self.current_span()?;","highlight_start":17,"highlight_end":27}],"label":"binding `start_span` declared here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":14943,"byte_end":14948,"line_start":459,"line_end":459,"column_start":35,"column_end":40,"is_primary":false,"text":[{"text":"            let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":35,"highlight_end":40}],"label":"borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":14942,"byte_end":14942,"line_start":459,"line_end":459,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"            let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0505]\u001b[0m\u001b[1m\u001b[97m: cannot move out of `start_span` because it is borrowed\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:459:72\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m430\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let start_span = self.current_span()?;\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mbinding `start_span` declared here\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m459\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let span = start_span.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[96mborrow later used by call\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmove out of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                        \u001b[1m\u001b[96mborrow of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m459\u001b[0m \u001b[1m\u001b[96m| \u001b[0m            let span = start_span\u001b[92m.clone()\u001b[0m.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"variable `index` is assigned to, but never used","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":13677,"byte_end":13686,"line_start":427,"line_end":427,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"        let mut index = 0i128;","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider using `_index` instead","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: variable `index` is assigned to, but never used\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:427:13\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m427\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let mut index = 0i128;\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[93m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: consider using `_index` instead\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"value assigned to `index` is never read","code":{"code":"unused_assignments","explanation":null},"level":"warning","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":15301,"byte_end":15311,"line_start":469,"line_end":469,"column_start":17,"column_end":27,"is_primary":true,"text":[{"text":"                index += 1;","highlight_start":17,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"maybe it is overwritten before being read?","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: value assigned to `index` is never read\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:469:17\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m469\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 index += 1;\n    \u001b[1m\u001b[96m|\u001b[0m                 \u001b[1m\u001b[93m^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: maybe it is overwritten before being read?\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"cannot move out of `start_span` because it is borrowed","code":{"code":"E0505","explanation":"A value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let _ref_to_val: &Value = &x;\n    eat(x);\n    borrow(_ref_to_val);\n}\n```\n\nHere, the function `eat` takes ownership of `x`. However,\n`x` cannot be moved because the borrow to `_ref_to_val`\nneeds to last till the function `borrow`.\nTo fix that you can do a few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    eat(&x); // pass by reference, if it's possible\n    borrow(ref_to_val);\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    borrow(ref_to_val);\n    // ref_to_val is no longer used.\n    eat(x);\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let ref_to_val: &Value = &x;\n    eat(x); // it will be copied here.\n    borrow(ref_to_val);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":21141,"byte_end":21151,"line_start":618,"line_end":618,"column_start":68,"column_end":78,"is_primary":true,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":68,"highlight_end":78}],"label":"move out of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":21093,"byte_end":21103,"line_start":618,"line_end":618,"column_start":20,"column_end":30,"is_primary":false,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":20,"highlight_end":30}],"label":"borrow of `start_span` occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":20801,"byte_end":20811,"line_start":611,"line_end":611,"column_start":13,"column_end":23,"is_primary":false,"text":[{"text":"        let start_span = self.current_span()?;","highlight_start":13,"highlight_end":23}],"label":"binding `start_span` declared here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":21104,"byte_end":21109,"line_start":618,"line_end":618,"column_start":31,"column_end":36,"is_primary":false,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":31,"highlight_end":36}],"label":"borrow later used by call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":21103,"byte_end":21103,"line_start":618,"line_end":618,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"        let span = start_span.merge(&self.current_span().unwrap_or(start_span));","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0505]\u001b[0m\u001b[1m\u001b[97m: cannot move out of `start_span` because it is borrowed\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:618:68\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m611\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let start_span = self.current_span()?;\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mbinding `start_span` declared here\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m618\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let span = start_span.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[96mborrow later used by call\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmove out of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                    \u001b[1m\u001b[96mborrow of `start_span` occurs here\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m618\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        let span = start_span\u001b[92m.clone()\u001b[0m.merge(&self.current_span().unwrap_or(start_span));\n    \u001b[1m\u001b[96m|\u001b[0m                              \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of moved value: `start_span`","code":{"code":"E0382","explanation":"A variable was used after its contents have been moved elsewhere.\n\nErroneous code example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`. Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the\n[Understanding Ownership][understanding-ownership] chapter in the Book.\n\n[understanding-ownership]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":24314,"byte_end":24324,"line_start":714,"line_end":714,"column_start":23,"column_end":33,"is_primary":false,"text":[{"text":"                span: start_span,","highlight_start":23,"highlight_end":33}],"label":"value moved here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":24360,"byte_end":24370,"line_start":716,"line_end":716,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"            span: start_span,","highlight_start":19,"highlight_end":29}],"label":"value used here after move","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":23639,"byte_end":23649,"line_start":693,"line_end":693,"column_start":13,"column_end":23,"is_primary":false,"text":[{"text":"        let start_span = self.current_span()?;","highlight_start":13,"highlight_end":23}],"label":"move occurs because `start_span` has type `Span`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":24324,"byte_end":24324,"line_start":714,"line_end":714,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"                span: start_span,","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0382]\u001b[0m\u001b[1m\u001b[97m: use of moved value: `start_span`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:716:19\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m693\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let start_span = self.current_span()?;\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mmove occurs because `start_span` has type `Span`, which does not implement the `Copy` trait\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m714\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 span: start_span,\n    \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mvalue moved here\u001b[0m\n\u001b[1m\u001b[96m715\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             }),\n\u001b[1m\u001b[96m716\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             span: start_span,\n    \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvalue used here after move\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m714\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                span: start_span\u001b[92m.clone()\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of moved value: `start_span`","code":{"code":"E0382","explanation":"A variable was used after its contents have been moved elsewhere.\n\nErroneous code example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`. Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the\n[Understanding Ownership][understanding-ownership] chapter in the Book.\n\n[understanding-ownership]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":25935,"byte_end":25945,"line_start":774,"line_end":774,"column_start":23,"column_end":33,"is_primary":false,"text":[{"text":"                span: start_span,","highlight_start":23,"highlight_end":33}],"label":"value moved here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":25981,"byte_end":25991,"line_start":776,"line_end":776,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"            span: start_span,","highlight_start":19,"highlight_end":29}],"label":"value used here after move","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":25724,"byte_end":25734,"line_start":767,"line_end":767,"column_start":13,"column_end":23,"is_primary":false,"text":[{"text":"        let start_span = self.current_span()?;","highlight_start":13,"highlight_end":23}],"label":"move occurs because `start_span` has type `Span`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":25945,"byte_end":25945,"line_start":774,"line_end":774,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"                span: start_span,","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0382]\u001b[0m\u001b[1m\u001b[97m: use of moved value: `start_span`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:776:19\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m767\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let start_span = self.current_span()?;\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mmove occurs because `start_span` has type `Span`, which does not implement the `Copy` trait\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m774\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 span: start_span,\n    \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mvalue moved here\u001b[0m\n\u001b[1m\u001b[96m775\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             }),\n\u001b[1m\u001b[96m776\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             span: start_span,\n    \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvalue used here after move\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m774\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                span: start_span\u001b[92m.clone()\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of moved value: `start_span`","code":{"code":"E0382","explanation":"A variable was used after its contents have been moved elsewhere.\n\nErroneous code example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`. Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the\n[Understanding Ownership][understanding-ownership] chapter in the Book.\n\n[understanding-ownership]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":26408,"byte_end":26418,"line_start":792,"line_end":792,"column_start":23,"column_end":33,"is_primary":false,"text":[{"text":"                span: start_span,","highlight_start":23,"highlight_end":33}],"label":"value moved here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":26454,"byte_end":26464,"line_start":794,"line_end":794,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"            span: start_span,","highlight_start":19,"highlight_end":29}],"label":"value used here after move","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":26124,"byte_end":26134,"line_start":783,"line_end":783,"column_start":13,"column_end":23,"is_primary":false,"text":[{"text":"        let start_span = self.current_span()?;","highlight_start":13,"highlight_end":23}],"label":"move occurs because `start_span` has type `Span`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":26418,"byte_end":26418,"line_start":792,"line_end":792,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"                span: start_span,","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0382]\u001b[0m\u001b[1m\u001b[97m: use of moved value: `start_span`\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:794:19\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m783\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         let start_span = self.current_span()?;\n    \u001b[1m\u001b[96m|\u001b[0m             \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mmove occurs because `start_span` has type `Span`, which does not implement the `Copy` trait\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m792\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                 span: start_span,\n    \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[96m----------\u001b[0m \u001b[1m\u001b[96mvalue moved here\u001b[0m\n\u001b[1m\u001b[96m793\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             }),\n\u001b[1m\u001b[96m794\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             span: start_span,\n    \u001b[1m\u001b[96m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvalue used here after move\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m792\u001b[0m \u001b[1m\u001b[96m| \u001b[0m                span: start_span\u001b[92m.clone()\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m                                 \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot move out of `token.span` which is behind a shared reference","code":{"code":"E0507","explanation":"A borrowed value was moved out.\n\nErroneous code example:\n\n```compile_fail,E0507\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n}\n```\n\nHere, the `nothing_is_true` method takes the ownership of `self`. However,\n`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\nwhich is a borrow of the content owned by the `RefCell`. To fix this error,\nyou have three choices:\n\n* Try to avoid moving the variable.\n* Somehow reclaim the ownership.\n* Implement the `Copy` trait on the type.\n\nThis can also happen when using a type implementing `Fn` or `FnMut`, as neither\nallows moving out of them (they usually represent closures which can be called\nmore than once). Much of the text following applies equally well to non-`FnOnce`\nclosure bodies.\n\nExamples:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(&self) {} // First case, we don't take ownership\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n    let x = x.into_inner(); // we get back ownership\n\n    x.nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\n#[derive(Clone, Copy)] // we implement the Copy trait\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nMoving a member out of a mutably borrowed struct will also cause E0507 error:\n\n```compile_fail,E0507\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nstruct Batcave {\n    knight: TheDarkKnight\n}\n\nfn main() {\n    let mut cave = Batcave {\n        knight: TheDarkKnight\n    };\n    let borrowed = &mut cave;\n\n    borrowed.knight.nothing_is_true(); // E0507\n}\n```\n\nIt is fine only if you put something back. `mem::replace` can be used for that:\n\n```\n# struct TheDarkKnight;\n# impl TheDarkKnight { fn nothing_is_true(self) {} }\n# struct Batcave { knight: TheDarkKnight }\nuse std::mem;\n\nlet mut cave = Batcave {\n    knight: TheDarkKnight\n};\nlet borrowed = &mut cave;\n\nmem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":66296,"byte_end":66306,"line_start":1896,"line_end":1896,"column_start":16,"column_end":26,"is_primary":true,"text":[{"text":"            Ok(token.span)","highlight_start":16,"highlight_end":26}],"label":"move occurs because `token.span` has type `Span`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider cloning the value if the performance cost is acceptable","code":null,"level":"help","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":66306,"byte_end":66306,"line_start":1896,"line_end":1896,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"            Ok(token.span)","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0507]\u001b[0m\u001b[1m\u001b[97m: cannot move out of `token.span` which is behind a shared reference\u001b[0m\n    \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:1896:16\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1896\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             Ok(token.span)\n     \u001b[1m\u001b[96m|\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmove occurs because `token.span` has type `Span`, which does not implement the `Copy` trait\u001b[0m\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider cloning the value if the performance cost is acceptable\n     \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m1896\u001b[0m \u001b[1m\u001b[96m| \u001b[0m            Ok(token.span\u001b[92m.clone()\u001b[0m)\n     \u001b[1m\u001b[96m|\u001b[0m                          \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `lasso`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":285,"byte_end":290,"line_start":11,"line_end":11,"column_start":23,"column_end":28,"is_primary":true,"text":[{"text":"    interner: &'a mut lasso::Rodeo,","highlight_start":23,"highlight_end":28}],"label":"use of unresolved module or unlinked crate `lasso`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `lasso`, use `cargo add lasso` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of unresolved module or unlinked crate `lasso`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:11:23\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m11\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     interner: &'a mut lasso::Rodeo,\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91muse of unresolved module or unlinked crate `lasso`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: if you wanted to use a crate named `lasso`, use `cargo add lasso` to add it to your `Cargo.toml`\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `lasso`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"crates\\chim-parser\\src\\lib.rs","byte_start":433,"byte_end":438,"line_start":17,"line_end":17,"column_start":61,"column_end":66,"is_primary":true,"text":[{"text":"    pub fn new(tokens: Vec<SpannedToken>, interner: &'a mut lasso::Rodeo, file_id: FileId) -> Self {","highlight_start":61,"highlight_end":66}],"label":"use of unresolved module or unlinked crate `lasso`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `lasso`, use `cargo add lasso` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m\u001b[97m: failed to resolve: use of unresolved module or unlinked crate `lasso`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mcrates\\chim-parser\\src\\lib.rs:17:61\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m17\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn new(tokens: Vec<SpannedToken>, interner: &'a mut lasso::Rodeo, file_id: FileId) -> Self {\n   \u001b[1m\u001b[96m|\u001b[0m                                                             \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91muse of unresolved module or unlinked crate `lasso`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: if you wanted to use a crate named `lasso`, use `cargo add lasso` to add it to your `Cargo.toml`\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 141 previous errors; 3 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: aborting due to 141 previous errors; 3 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0061, E0271, E0277, E0308, E0382, E0433, E0505, E0507, E0532...","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mSome errors have detailed explanations: E0061, E0271, E0277, E0308, E0382, E0433, E0505, E0507, E0532...\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0061`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about an error, try `rustc --explain E0061`.\u001b[0m\n"}
