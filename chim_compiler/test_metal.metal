/* Generated by Chim Compiler - Metal Backend */
/* Target: Apple Metal Shading Language */
/* Platform: macOS/iOS/iPadOS */

#include <metal_stdlib>
using namespace metal;

// Metal Compute Kernels
kernel void add(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    constant uint& dataSize [[buffer(2)]],
    uint gid [[thread_position_in_grid]],
    uint tid [[thread_position_in_threadgroup]],
    uint tgid [[threadgroup_position_in_grid]]
) {
    // Thread indexing
    uint index = gid;
    if (index >= dataSize) return;

    // Threadgroup (shared) memory
    threadgroup float sharedData[256];

    // SIMD operations
    simd_float4 vecData;

    auto .tmp2 = b;
    float .tmp3 = .tmp2 + .tmp3;
    // Unsupported instruction

    // Synchronization
    threadgroup_barrier(mem_flags::mem_threadgroup);
}

kernel void multiply(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    constant uint& dataSize [[buffer(2)]],
    uint gid [[thread_position_in_grid]],
    uint tid [[thread_position_in_threadgroup]],
    uint tgid [[threadgroup_position_in_grid]]
) {
    // Thread indexing
    uint index = gid;
    if (index >= dataSize) return;

    // Threadgroup (shared) memory
    threadgroup float sharedData[256];

    // SIMD operations
    simd_float4 vecData;

    auto .tmp5 = y;
    float .tmp6 = .tmp5 * .tmp6;
    // Unsupported instruction

    // Synchronization
    threadgroup_barrier(mem_flags::mem_threadgroup);
}

kernel void main(
    device float* input [[buffer(0)]],
    device float* output [[buffer(1)]],
    constant uint& dataSize [[buffer(2)]],
    uint gid [[thread_position_in_grid]],
    uint tid [[thread_position_in_threadgroup]],
    uint tgid [[threadgroup_position_in_grid]]
) {
    // Thread indexing
    uint index = gid;
    if (index >= dataSize) return;

    // Threadgroup (shared) memory
    threadgroup float sharedData[256];

    // SIMD operations
    simd_float4 vecData;

    float .tmp9 = add(.tmp7, .tmp8);
    float .tmp12 = multiply(.tmp10, .tmp11);

    // Synchronization
    threadgroup_barrier(mem_flags::mem_threadgroup);
}

// Metal C++ Host Code (Objective-C++)
#import <Metal/Metal.h>

void executeKernels() {
    // Get Metal device
    id<MTLDevice> device = MTLCreateSystemDefaultDevice();
    id<MTLCommandQueue> commandQueue = [device newCommandQueue];

    // Execute add kernel
    id<MTLCommandBuffer> commandBuffer = [commandQueue commandBuffer];
    id<MTLComputeCommandEncoder> encoder = [commandBuffer computeCommandEncoder];
    [encoder setComputePipelineState:addPipeline];
    [encoder setBuffer:inputBuffer offset:0 atIndex:0];
    [encoder setBuffer:outputBuffer offset:0 atIndex:1];

    MTLSize threadgroupSize = MTLSizeMake(256, 1, 1);
    MTLSize gridSize = MTLSizeMake(dataSize, 1, 1);
    [encoder dispatchThreads:gridSize threadsPerThreadgroup:threadgroupSize];
    [encoder endEncoding];
    [commandBuffer commit];
    [commandBuffer waitUntilCompleted];

    // Execute multiply kernel
    id<MTLCommandBuffer> commandBuffer = [commandQueue commandBuffer];
    id<MTLComputeCommandEncoder> encoder = [commandBuffer computeCommandEncoder];
    [encoder setComputePipelineState:multiplyPipeline];
    [encoder setBuffer:inputBuffer offset:0 atIndex:0];
    [encoder setBuffer:outputBuffer offset:0 atIndex:1];

    MTLSize threadgroupSize = MTLSizeMake(256, 1, 1);
    MTLSize gridSize = MTLSizeMake(dataSize, 1, 1);
    [encoder dispatchThreads:gridSize threadsPerThreadgroup:threadgroupSize];
    [encoder endEncoding];
    [commandBuffer commit];
    [commandBuffer waitUntilCompleted];

    // Execute main kernel
    id<MTLCommandBuffer> commandBuffer = [commandQueue commandBuffer];
    id<MTLComputeCommandEncoder> encoder = [commandBuffer computeCommandEncoder];
    [encoder setComputePipelineState:mainPipeline];
    [encoder setBuffer:inputBuffer offset:0 atIndex:0];
    [encoder setBuffer:outputBuffer offset:0 atIndex:1];

    MTLSize threadgroupSize = MTLSizeMake(256, 1, 1);
    MTLSize gridSize = MTLSizeMake(dataSize, 1, 1);
    [encoder dispatchThreads:gridSize threadsPerThreadgroup:threadgroupSize];
    [encoder endEncoding];
    [commandBuffer commit];
    [commandBuffer waitUntilCompleted];

}
