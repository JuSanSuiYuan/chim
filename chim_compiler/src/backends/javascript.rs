use crate::backend::CodegenBackend;
use crate::ir::{Module, Function, Instruction, Type};
use std::error::Error;

/// JavaScript后端 - 生成ES6+代码
/// 
/// 特点：
/// - Modern ES6+ 语法
/// - const/let变量声明
/// - 箭头函数支持
/// - 模块化export
pub struct JavaScriptBackend {
    use_strict: bool,
    use_modules: bool,
}

impl JavaScriptBackend {
    pub fn new() -> Self {
        Self {
            use_strict: true,
            use_modules: true,
        }
    }
    
    /// 生成函数签名
    fn generate_function_signature(&self, func: &Function) -> String {
        format!("function {}({})", 
            func.name,
            func.params.iter()
                .map(|(name, _)| name.clone())
                .collect::<Vec<_>>()
                .join(", ")
        )
    }
    
    /// 生成指令代码
    fn generate_instruction(&self, inst: &Instruction, indent: usize) -> String {
        let ind = "  ".repeat(indent);
        
        match inst {
            Instruction::Alloca { dest, .. } => {
                format!("{}let {};", ind, dest)
            }
            Instruction::Store { dest, src } => {
                format!("{}{} = {};", ind, dest, src)
            }
            Instruction::Load { dest, src } => {
                format!("{}const {} = {};", ind, dest, src)
            }
            Instruction::Add { dest, left, right } => {
                format!("{}const {} = {} + {};", ind, dest, left, right)
            }
            Instruction::Sub { dest, left, right } => {
                format!("{}const {} = {} - {};", ind, dest, left, right)
            }
            Instruction::Mul { dest, left, right } => {
                format!("{}const {} = {} * {};", ind, dest, left, right)
            }
            Instruction::Div { dest, left, right } => {
                format!("{}const {} = {} / {};", ind, dest, left, right)
            }
            Instruction::Mod { dest, left, right } => {
                format!("{}const {} = {} % {};", ind, dest, left, right)
            }
            Instruction::Eq { dest, left, right } => {
                format!("{}const {} = ({} === {});", ind, dest, left, right)
            }
            Instruction::Ne { dest, left, right } => {
                format!("{}const {} = ({} !== {});", ind, dest, left, right)
            }
            Instruction::Lt { dest, left, right } => {
                format!("{}const {} = ({} < {});", ind, dest, left, right)
            }
            Instruction::Le { dest, left, right } => {
                format!("{}const {} = ({} <= {});", ind, dest, left, right)
            }
            Instruction::Gt { dest, left, right } => {
                format!("{}const {} = ({} > {});", ind, dest, left, right)
            }
            Instruction::Ge { dest, left, right } => {
                format!("{}const {} = ({} >= {});", ind, dest, left, right)
            }
            Instruction::And { dest, left, right } => {
                format!("{}const {} = ({} && {});", ind, dest, left, right)
            }
            Instruction::Or { dest, left, right } => {
                format!("{}const {} = ({} || {});", ind, dest, left, right)
            }
            Instruction::Not { dest, src } => {
                format!("{}const {} = !{};", ind, dest, src)
            }
            Instruction::Call { dest, func, args } => {
                if let Some(d) = dest {
                    format!("{}const {} = {}({});", ind, d, func, args.join(", "))
                } else {
                    format!("{}{}({});", ind, func, args.join(", "))
                }
            }
            Instruction::Return(Some(value)) => {
                format!("{}return {};", ind, value)
            }
            Instruction::Return(None) => {
                format!("{}return;", ind)
            }
            Instruction::ReturnInPlace(value) => {
                format!("{}return {}; // RVO", ind, value)
            }
            _ => format!("{}// Unsupported instruction", ind),
        }
    }
    
    /// 生成函数代码
    fn generate_function(&self, func: &Function) -> String {
        let mut code = String::new();
        
        // 函数签名
        code.push_str(&self.generate_function_signature(func));
        code.push_str(" {\n");
        
        // 函数体
        for inst in &func.body {
            code.push_str(&self.generate_instruction(inst, 1));
            code.push('\n');
        }
        
        code.push_str("}\n\n");
        code
    }
}

impl CodegenBackend for JavaScriptBackend {
    fn name(&self) -> &str {
        "JavaScript"
    }
    
    fn generate(&self, module: &Module) -> Result<String, Box<dyn Error>> {
        let mut output = String::new();
        
        // 文件头部
        output.push_str("// Generated by Chim Compiler - JavaScript Backend\n");
        output.push_str("// Target: ES6+ (ECMAScript 2015+)\n");
        output.push_str("// Features: const/let, arrow functions, modules\n\n");
        
        if self.use_strict {
            output.push_str("'use strict';\n\n");
        }
        
        // 生成所有函数
        for func in &module.functions {
            output.push_str(&self.generate_function(func));
        }
        
        // 导出（如果使用模块）
        if self.use_modules {
            output.push_str("// Export functions\n");
            output.push_str("module.exports = {\n");
            for (i, func) in module.functions.iter().enumerate() {
                if i > 0 {
                    output.push_str(",\n");
                }
                output.push_str(&format!("  {}", func.name));
            }
            output.push_str("\n};\n");
        }
        
        Ok(output)
    }
    
    fn file_extension(&self) -> &str {
        "js"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_javascript_backend() {
        let backend = JavaScriptBackend::new();
        assert_eq!(backend.name(), "JavaScript");
        assert_eq!(backend.file_extension(), "js");
    }
}
