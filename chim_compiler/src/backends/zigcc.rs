use crate::backend::CodegenBackend;
use crate::ir::{Module, Function, Instruction, Type};
use std::error::Error;

/// Zig cc 后端 - Zig 的 C 编译器
pub struct ZigCCBackend;

impl ZigCCBackend {
    pub fn new() -> Self {
        Self
    }

    fn generate_type(&self, ty: &Type) -> String {
        match ty {
            Type::Void => "void".to_string(),
            Type::Int32 => "i32".to_string(),
            Type::Int64 => "i64".to_string(),
            Type::Float32 => "f32".to_string(),
            Type::Float64 => "f64".to_string(),
            Type::Bool => "bool".to_string(),
            Type::String => "[*:0]const u8".to_string(),
            Type::Ptr(inner) => format!("*{}", self.generate_type(inner)),
            Type::Ref(inner) | Type::MutRef(inner) => {
                format!("*{}", self.generate_type(inner))
            },
            Type::Array(inner, size) => {
                format!("[{}]{}", size, self.generate_type(inner))
            },
            Type::Struct(name) => name.clone(),
        }
    }

    fn generate_function(&self, func: &Function) -> String {
        let mut code = String::new();
        
        code.push_str(&format!("export fn {}(", func.name));
        
        for (i, (name, ty)) in func.params.iter().enumerate() {
            if i > 0 { code.push_str(", "); }
            code.push_str(&format!("{}: {}", name, self.generate_type(ty)));
        }
        
        code.push_str(&format!(") {} {{\n", self.generate_type(&func.return_type)));
        
        for inst in &func.body {
            match inst {
                Instruction::Load { dest, src } => {
                    code.push_str(&format!("    var {} = {};\n", dest, src));
                },
                Instruction::Add { dest, left, right } => {
                    code.push_str(&format!("    var {} = {} + {};\n", dest, left, right));
                },
                Instruction::Return(value) => {
                    if let Some(val) = value {
                        code.push_str(&format!("    return {};\n", val));
                    }
                },
                Instruction::ReturnInPlace(value) => {
                    code.push_str(&format!("    return {}; // RVO\n", value));
                },
                _ => {},
            }
        }
        
        code.push_str("}\n");
        code
    }
}

impl CodegenBackend for ZigCCBackend {
    fn name(&self) -> &str {
        "Zig cc"
    }

    fn generate(&self, module: &Module) -> Result<String, Box<dyn Error>> {
        let mut code = String::new();
        
        code.push_str("// Generated by Chim Compiler - Zig cc Backend\n");
        code.push_str("// Target: Zig C Compiler\n\n");
        
        code.push_str("const std = @import(\"std\");\n\n");
        
        for func in &module.functions {
            code.push_str(&self.generate_function(func));
            code.push_str("\n");
        }
        
        Ok(code)
    }

    fn file_extension(&self) -> &str {
        "zig"
    }
}
