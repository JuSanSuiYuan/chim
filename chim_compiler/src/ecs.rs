/// ECS (Entity-Component-System) 运行时模块
/// 提供数据导向设计的内置支持

use std::collections::HashMap;
use crate::ast::{Statement, Expression, StructField};
use crate::ir::{Module, Function, Instruction, Type};

/// ECS实体ID类型
pub type EntityId = u64;

/// ECS组件定义
#[derive(Debug, Clone)]
pub struct ComponentDef {
    pub name: String,
    pub fields: Vec<StructField>,
    pub id: u32,
}

/// ECS系统定义
#[derive(Debug, Clone)]
pub struct SystemDef {
    pub name: String,
    pub query_components: Vec<String>,
    pub body: Expression,
}

/// ECS实体原型
#[derive(Debug, Clone)]
pub struct EntityArchetype {
    pub name: String,
    pub components: Vec<String>,
}

/// ECS世界管理器
#[derive(Clone)]
pub struct ECSWorld {
    /// 组件类型注册表
    pub components: HashMap<String, ComponentDef>,
    /// 系统注册表
    pub systems: Vec<SystemDef>,
    /// 实体原型
    pub archetypes: HashMap<String, EntityArchetype>,
    /// 下一个组件ID
    next_component_id: u32,
}

impl ECSWorld {
    pub fn new() -> Self {
        Self {
            components: HashMap::new(),
            systems: Vec::new(),
            archetypes: HashMap::new(),
            next_component_id: 0,
        }
    }
    
    /// 注册组件类型
    pub fn register_component(&mut self, name: String, fields: Vec<StructField>) {
        let id = self.next_component_id;
        self.next_component_id += 1;
        
        let comp_def = ComponentDef {
            name: name.clone(),
            fields,
            id,
        };
        
        self.components.insert(name, comp_def);
    }
    
    /// 注册系统
    pub fn register_system(&mut self, name: String, query: Vec<String>, body: Expression) {
        let sys_def = SystemDef {
            name,
            query_components: query,
            body,
        };
        
        self.systems.push(sys_def);
    }
    
    /// 注册实体原型
    pub fn register_entity_archetype(&mut self, name: String, components: Vec<String>) {
        let archetype = EntityArchetype {
            name: name.clone(),
            components,
        };
        
        self.archetypes.insert(name, archetype);
    }
    
    /// 生成ECS运行时代码（面向数据的存储布局）
    pub fn generate_runtime_code(&self) -> String {
        let mut code = String::new();
        
        code.push_str("// ECS Runtime - Data-Oriented Design\n");
        code.push_str("// Generated by Chim Compiler\n\n");
        
        // 生成组件存储结构（SoA - Structure of Arrays）
        code.push_str("// Component Storage (SoA Layout)\n");
        for (comp_name, comp_def) in &self.components {
            code.push_str(&format!("struct {}Storage {{\n", comp_name));
            
            // 为每个字段创建独立的数组
            for field in &comp_def.fields {
                code.push_str(&format!("    {}_data: Vec<{}>,\n", 
                    field.name, 
                    Self::map_type(&field.ty)
                ));
            }
            
            code.push_str("    entity_ids: Vec<u64>,\n");
            code.push_str("    count: usize,\n");
            code.push_str("}\n\n");
            
            // 生成访问方法
            code.push_str(&format!("impl {}Storage {{\n", comp_name));
            code.push_str("    fn new() -> Self {\n");
            code.push_str("        Self {\n");
            for field in &comp_def.fields {
                code.push_str(&format!("            {}_data: Vec::new(),\n", field.name));
            }
            code.push_str("            entity_ids: Vec::new(),\n");
            code.push_str("            count: 0,\n");
            code.push_str("        }\n");
            code.push_str("    }\n");
            
            // 添加组件
            code.push_str(&format!("    fn add(&mut self, entity: u64, comp: {}) {{\n", comp_name));
            for field in &comp_def.fields {
                code.push_str(&format!("        self.{}_data.push(comp.{});\n", 
                    field.name, field.name));
            }
            code.push_str("        self.entity_ids.push(entity);\n");
            code.push_str("        self.count += 1;\n");
            code.push_str("    }\n");
            
            code.push_str("}\n\n");
        }
        
        // 生成世界管理器
        code.push_str("// ECS World Manager\n");
        code.push_str("struct World {\n");
        for comp_name in self.components.keys() {
            code.push_str(&format!("    {}_storage: {}Storage,\n", 
                comp_name.to_lowercase(), comp_name));
        }
        code.push_str("    next_entity_id: u64,\n");
        code.push_str("}\n\n");
        
        code.push_str("impl World {\n");
        code.push_str("    fn new() -> Self {\n");
        code.push_str("        Self {\n");
        for comp_name in self.components.keys() {
            code.push_str(&format!("            {}_storage: {}Storage::new(),\n", 
                comp_name.to_lowercase(), comp_name));
        }
        code.push_str("            next_entity_id: 0,\n");
        code.push_str("        }\n");
        code.push_str("    }\n");
        
        // 创建实体
        code.push_str("    fn create_entity(&mut self) -> u64 {\n");
        code.push_str("        let id = self.next_entity_id;\n");
        code.push_str("        self.next_entity_id += 1;\n");
        code.push_str("        id\n");
        code.push_str("    }\n");
        
        code.push_str("}\n\n");
        
        // 生成系统执行代码
        if !self.systems.is_empty() {
            code.push_str("// System Execution\n");
            code.push_str("impl World {\n");
            
            for system in &self.systems {
                code.push_str(&format!("    fn run_{}(&mut self) {{\n", system.name));
                code.push_str(&format!("        // Query components: {:?}\n", 
                    system.query_components));
                
                // 生成组件迭代逻辑
                if !system.query_components.is_empty() {
                    let first_comp = &system.query_components[0];
                    code.push_str(&format!(
                        "        let count = self.{}_storage.count;\n", 
                        first_comp.to_lowercase()
                    ));
                    code.push_str("        for i in 0..count {\n");
                    
                    // 访问每个组件的数据
                    for comp in &system.query_components {
                        code.push_str(&format!(
                            "            // Access {} component data\n", 
                            comp
                        ));
                    }
                    
                    code.push_str("            // System logic here\n");
                    code.push_str("        }\n");
                }
                
                code.push_str("    }\n\n");
            }
            
            code.push_str("}\n\n");
        }
        
        code
    }
    
    /// 映射类型名称
    fn map_type(ty: &str) -> &str {
        match ty {
            "int" => "i32",
            "float" => "f32",
            "double" => "f64",
            "bool" => "bool",
            "string" => "String",
            _ => ty,
        }
    }
    
    /// 分析并提取ECS声明
    pub fn analyze_statements(&mut self, statements: &[Statement]) {
        for stmt in statements {
            match stmt {
                Statement::Component { name, fields } => {
                    self.register_component(name.clone(), fields.clone());
                }
                Statement::System { name, query, body } => {
                    self.register_system(name.clone(), query.clone(), body.clone());
                }
                Statement::Entity { name, components } => {
                    self.register_entity_archetype(name.clone(), components.clone());
                }
                _ => {}
            }
        }
    }
}

/// ECS优化器 - 为ECS代码应用数据导向优化
pub struct ECSOptimizer {
    world: ECSWorld,
}

impl ECSOptimizer {
    pub fn new() -> Self {
        Self {
            world: ECSWorld::new(),
        }
    }
    
    pub fn optimize(&mut self, statements: &[Statement]) -> ECSWorld {
        self.world.analyze_statements(statements);
        self.world.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_ecs_world() {
        let mut world = ECSWorld::new();
        
        // 注册组件
        world.register_component(
            "Position".to_string(),
            vec![
                StructField { name: "x".to_string(), ty: "float".to_string() },
                StructField { name: "y".to_string(), ty: "float".to_string() },
            ]
        );
        
        world.register_component(
            "Velocity".to_string(),
            vec![
                StructField { name: "dx".to_string(), ty: "float".to_string() },
                StructField { name: "dy".to_string(), ty: "float".to_string() },
            ]
        );
        
        // 生成代码
        let code = world.generate_runtime_code();
        
        assert!(code.contains("PositionStorage"));
        assert!(code.contains("VelocityStorage"));
        assert!(code.contains("World"));
    }
}
