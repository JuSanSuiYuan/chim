// 优化器测试 - 验证DCE、CSE和代数化简

// 测试1：死代码消除
fn test_dead_code() -> int = {
    let x: int = 10;
    let y: int = 20;  // 未使用，应被消除
    let z: int = 30;  // 未使用，应被消除
    return x
}

// 测试2：公共子表达式消除
fn test_cse(a: int, b: int) -> int = {
    let x: int = a + b;
    let y: int = a + b;  // 重复计算，应被消除
    let z: int = x + y;
    return z
}

// 测试3：代数化简
fn test_algebraic(x: int) -> int = {
    let a: int = x + 0;    // 应简化为 a = x
    let b: int = x * 1;    // 应简化为 b = x
    let c: int = x * 0;    // 应简化为 c = 0
    let d: int = a + b + c;
    return d
}

// 测试4：常数传播 + 代数化简
fn test_constant_fold() -> int = {
    let a: int = 10 + 5;     // 应在编译时计算为15
    let b: int = 20 * 2;     // 应在编译时计算为40
    let c: int = a + b;      // 应在编译时计算为55
    return c
}

// 测试5：综合优化
fn test_combined(x: int) -> int = {
    let unused1: int = 100;  // 死代码
    let unused2: int = 200;  // 死代码
    
    let a: int = x + 0;      // 代数化简
    let b: int = x + 0;      // CSE + 代数化简
    
    let c: int = 5 * 2;      // 常数折叠
    let d: int = a + b + c;
    
    let unused3: int = 999;  // 死代码
    
    return d
}

fn main() -> int = {
    let result1: int = test_dead_code();
    let result2: int = test_cse(10, 20);
    let result3: int = test_algebraic(42);
    let result4: int = test_constant_fold();
    let result5: int = test_combined(7);
    
    return result5
}
