use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum UnisonType {
    Unit,
    Boolean,
    Int,
    Int8,
    Int16,
    Int32,
    Int64,
    Nat,
    Nat8,
    Nat16,
    Nat32,
    Nat64,
    Float,
    Float32,
    Float64,
    Text,
    Char,
    Bytes,
    Array(Box<UnisonType>),
    List(Box<UnisonType>),
    Map(Box<UnisonType>, Box<UnisonType>),
    Set(Box<UnisonType>),
    Optional(Box<UnisonType>),
    Result(Box<UnisonType>, Box<UnisonType>),
    Tuple(Vec<UnisonType>),
    Function(Vec<UnisonType>, Box<UnisonType>),
    Ref(Box<UnisonType>),
    Ability(String),
    Request(Box<UnisonType>, Box<UnisonType>),
    Any,
}

#[derive(Debug, Clone)]
pub struct UnisonFunction {
    pub name: String,
    pub return_type: UnisonType,
    pub params: Vec<UnisonParameter>,
    pub is_public: bool,
    pub abilities: Vec<String>,
    pub body: Option<String>,
}

#[derive(Debug, Clone)]
pub struct UnisonParameter {
    pub name: String,
    pub param_type: UnisonType,
    pub default_value: Option<String>,
}

#[derive(Debug, Clone)]
pub struct UnisonStruct {
    pub name: String,
    pub fields: Vec<UnisonField>,
    pub is_public: bool,
}

#[derive(Debug, Clone)]
pub struct UnisonField {
    pub name: String,
    pub field_type: UnisonType>,
    pub is_mutable: bool,
}

#[derive(Debug, Clone)]
pub struct UnisonAbility {
    pub name: String,
    pub operations: Vec<UnisonOperation>,
}

#[derive(Debug, Clone)]
pub struct UnisonOperation {
    pub name: String,
    pub return_type: UnisonType>,
    pub params: Vec<UnisonParameter>,
}

#[derive(Debug, Clone)]
pub struct UnisonHandler {
    pub name: String,
    pub ability: String,
    pub operations: Vec<UnisonFunction>,
}

#[derive(Debug, Clone)]
pub struct UnisonModule {
    pub name: String,
    pub imports: Vec<String>,
    pub declarations: Vec<UnisonDeclaration>,
}

#[derive(Debug, Clone)]
pub enum UnisonDeclaration {
    Struct(UnisonStruct),
    Function(UnisonFunction),
    Ability(UnisonAbility),
    Handler(UnisonHandler),
}

#[derive(Debug, Clone)]
pub struct UnisonFFIGenerator {
    type_mapping: HashMap<String, UnisonType>,
    builtin_abilities: Vec<String>,
}

impl UnisonFFIGenerator {
    pub fn new() -> Self {
        let mut generator = Self {
            type_mapping: HashMap::new(),
            builtin_abilities: vec![
                "IO".to_string(),
                "Network".to_string(),
                "FileSystem".to_string(),
                "Time".to_string(),
                "Random".to_string(),
                "Concurrent".to_string(),
                "Store".to_string(),
                "TextIO".to_string(),
                "BytesIO".to_string(),
            ],
        };
        generator.init_type_mapping();
        generator
    }

    fn init_type_mapping(&mut self) {
        self.type_mapping
            .insert("c_void".to_string(), UnisonType::Unit);
        self.type_mapping
            .insert("c_bool".to_string(), UnisonType::Boolean);
        self.type_mapping
            .insert("c_int".to_string(), UnisonType::Int32);
        self.type_mapping
            .insert("c_long".to_string(), UnisonType::Int64);
        self.type_mapping
            .insert("c_float".to_string(), UnisonType::Float32);
        self.type_mapping
            .insert("c_double".to_string(), UnisonType::Float64);
        self.type_mapping
            .insert("c_string".to_string(), UnisonType::Text);
        self.type_mapping.insert(
            "c_voidptr".to_string(),
            UnisonType::Ref(Box::new(UnisonType::Unit)),
        );
    }

    pub fn generate_unison_module(&self, module: &UnisonModule) -> String {
        let mut output = String::new();

        output.push_str("-- Unison FFI Module\n");
        output.push_str("-- Generated by Chim Compiler\n\n");

        output.push_str(&format!("{}.{} : ", module.name, module.name));

        let decl_types: Vec<String> = module
            .declarations
            .iter()
            .map(|d| self.declaration_type_string(d))
            .collect();
        output.push_str(&decl_types.join("\n  Ã— "));
        output.push_str("\n\n");

        output.push_str(&format!("{}.{} =\n", module.name, module.name));

        for import in &module.imports {
            output.push_str(&format!("  use {}\n", import));
        }

        output.push_str("\n");

        for decl in &module.declarations {
            match decl {
                UnisonDeclaration::Struct(s) => self.generate_unison_struct(s, &mut output),
                UnisonDeclaration::Function(f) => self.generate_unison_function(f, &mut output),
                UnisonDeclaration::Ability(a) => self.generate_unison_ability(a, &mut output),
                UnisonDeclaration::Handler(h) => self.generate_unison_handler(h, &mut output),
            }
        }

        output
    }

    fn generate_unison_struct(&self, struct_: &UnisonStruct, output: &mut String) {
        let visibility = if struct_.is_public { "public " } else { "" };

        output.push_str(&format!("  {}struct {} : {{\n", visibility, struct_.name));

        for field in &struct_.fields {
            self.generate_unison_field(field, output);
        }

        output.push_str("  }\n\n");
    }

    fn generate_unison_field(&self, field: &UnisonField, output: &mut String) {
        let mutability = if field.is_mutable { "var " } else { "" };
        output.push_str(&format!(
            "    {}{} : {}\n",
            mutability,
            field.name,
            self.type_to_string(&field.field_type)
        ));
    }

    fn generate_unison_function(&self, func: &UnisonFunction, output: &mut String) {
        let visibility = if func.is_public { "public " } else { "" };

        output.push_str(&format!("  {}{} : ", visibility, func.name));

        for param in &func.params {
            output.push_str(&format!("{} -> ", self.type_to_string(&param.param_type)));
        }

        if !func.abilities.is_empty() {
            output.push_str(&format!("{{ {} }} ", func.abilities.join(", ")));
        }

        output.push_str(&format!("{}\n", self.type_to_string(&func.return_type)));

        output.push_str(&format!("  {} = ", func.name));

        for param in &func.params {
            output.push_str(&format!("{} ", param.name));
        }

        output.push_str("->\n");

        if let Some(body) = &func.body {
            output.push_str("    ");
            output.push_str(body.replace("\n", "\n    "));
            output.push_str("\n\n");
        } else {
            output.push_str("    todo \"TODO\"\n\n");
        }
    }

    fn generate_unison_ability(&self, ability: &UnisonAbility, output: &mut String) {
        output.push_str(&format!("  ability {} where\n", ability.name));

        for operation in &ability.operations {
            output.push_str(&format!("    {} : ", operation.name));

            for param in &operation.params {
                output.push_str(&format!("{} -> ", self.type_to_string(&param.param_type)));
            }

            output.push_str(&format!("{}\n", self.type_to_string(&operation.return_type)));
        }

        output.push_str("\n");
    }

    fn generate_unison_handler(&self, handler: &UnisonHandler, output: &mut String) {
        output.push_str(&format!("  {} = handle {} with\n", handler.name, handler.ability));

        for operation in &handler.operations {
            output.push_str(&format!("    {} = ", operation.name));

            for param in &operation.params {
                output.push_str(&format!("{} ", param.name));
            }

            output.push_str("->\n");

            if let Some(body) = &operation.body {
                output.push_str("      ");
                output.push_str(body.replace("\n", "\n      "));
                output.push_str("\n");
            } else {
                output.push_str("      todo \"TODO\"\n");
            }
        }

        output.push_str("\n");
    }

    fn declaration_type_string(&self, decl: &UnisonDeclaration) -> String {
        match decl {
            UnisonDeclaration::Struct(s) => {
                let field_types: Vec<String> = s
                    .fields
                    .iter()
                    .map(|f| self.type_to_string(&f.field_type))
                    .collect();
                format!("{} : {{ {} }}", s.name, field_types.join(", "))
            }
            UnisonDeclaration::Function(f) => {
                let param_types: Vec<String> = f
                    .params
                    .iter()
                    .map(|p| self.type_to_string(&p.param_type))
                    .collect();
                format!(
                    "{} : {} -> {}",
                    f.name,
                    param_types.join(" -> "),
                    self.type_to_string(&f.return_type)
                )
            }
            UnisonDeclaration::Ability(a) => format!("{} : Ability", a.name),
            UnisonDeclaration::Handler(h) => format!("{} : Handler", h.name),
        }
    }

    fn type_to_string(&self, ty: &UnisonType) -> String {
        match ty {
            UnisonType::Unit => "()".to_string(),
            UnisonType::Boolean => "Boolean".to_string(),
            UnisonType::Int => "Int".to_string(),
            UnisonType::Int8 => "Int8".to_string(),
            UnisonType::Int16 => "Int16".to_string(),
            UnisonType::Int32 => "Int32".to_string(),
            UnisonType::Int64 => "Int64".to_string(),
            UnisonType::Nat => "Nat".to_string(),
            UnisonType::Nat8 => "Nat8".to_string(),
            UnisonType::Nat16 => "Nat16".to_string(),
            UnisonType::Nat32 => "Nat32".to_string(),
            UnisonType::Nat64 => "Nat64".to_string(),
            UnisonType::Float => "Float".to_string(),
            UnisonType::Float32 => "Float32".to_string(),
            UnisonType::Float64 => "Float64".to_string(),
            UnisonType::Text => "Text".to_string(),
            UnisonType::Char => "Char".to_string(),
            UnisonType::Bytes => "[Byte]".to_string(),
            UnisonType::Array(inner) => {
                format!("[{}]", self.type_to_string(inner))
            }
            UnisonType::List(inner) => {
                format!("[{}]", self.type_to_string(inner))
            }
            UnisonType::Map(key, value) => {
                format!(
                    "Map {} {}",
                    self.type_to_string(key),
                    self.type_to_string(value)
                )
            }
            UnisonType::Set(inner) => {
                format!("Set {}", self.type_to_string(inner))
            }
            UnisonType::Optional(inner) => {
                format!("Optional {}", self.type_to_string(inner))
            }
            UnisonType::Result(ok, err) => {
                format!(
                    "Result {} {}",
                    self.type_to_string(ok),
                    self.type_to_string(err)
                )
            }
            UnisonType::Tuple(types) => {
                let type_strs: Vec<String> = types.iter().map(|t| self.type_to_string(t)).collect();
                format!("({})", type_strs.join(", "))
            }
            UnisonType::Function(params, ret) => {
                let param_strs: Vec<String> =
                    params.iter().map(|t| self.type_to_string(t)).collect();
                format!(
                    "({}) -> {}",
                    param_strs.join(" -> "),
                    self.type_to_string(ret)
                )
            }
            UnisonType::Ref(inner) => {
                format!("Ref {}", self.type_to_string(inner))
            }
            UnisonType::Ability(name) => name.clone(),
            UnisonType::Request(req, resp) => {
                format!(
                    "Request {} {}",
                    self.type_to_string(req),
                    self.type_to_string(resp)
                )
            }
            UnisonType::Any => "Any".to_string(),
        }
    }

    pub fn add_builtin_ability(&mut self, ability: String) {
        if !self.builtin_abilities.contains(&ability) {
            self.builtin_abilities.push(ability);
        }
    }
}

pub fn map_chim_type_to_unison(chim_type: &crate::Type) -> UnisonType {
    match chim_type {
        crate::Type::CVoid => UnisonType::Unit,
        crate::Type::CBool => UnisonType::Boolean,
        crate::Type::CChar => UnisonType::Char,
        crate::Type::CInt => UnisonType::Int32,
        crate::Type::CLong => UnisonType::Int64,
        crate::Type::CLongLong => UnisonType::Int64,
        crate::Type::CUChar => UnisonType::Nat8,
        crate::Type::CUShort => UnisonType::Nat16,
        crate::Type::CUInt => UnisonType::Nat32,
        crate::Type::CULong => UnisonType::Nat64,
        crate::Type::CULongLong => UnisonType::Nat64,
        crate::Type::CFloat => UnisonType::Float32,
        crate::Type::CDouble => UnisonType::Float64,
        crate::Type::CStr => UnisonType::Text,
        crate::Type::CVoidPtr => UnisonType::Ref(Box::new(UnisonType::Unit)),
        crate::Type::ISize => UnisonType::Int,
        crate::Type::USize => UnisonType::Nat,
        crate::Type::Pointer { target, .. } => {
            UnisonType::Ref(Box::new(map_chim_type_to_unison(target)))
        }
        crate::Type::Array { element, length: _ } => {
            UnisonType::Array(Box::new(map_chim_type_to_unison(element)))
        }
        crate::Type::Function { params, ret, .. } => {
            let param_types: Vec<UnisonType> =
                params.iter().map(|p| map_chim_type_to_unison(p)).collect();
            let ret_type = Box::new(map_chim_type_to_unison(ret));
            UnisonType::Function(param_types, ret_type)
        }
        crate::Type::Struct { name, .. } => UnisonType::Any,
        _ => UnisonType::Any,
    }
}
