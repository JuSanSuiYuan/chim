use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MoonBitType {
    Unit,
    Bool,
    Int,
    Int8,
    Int16,
    Int32,
    Int64,
    UInt,
    UInt8,
    UInt16,
    UInt32,
    UInt64,
    Float,
    Double,
    String,
    Bytes,
    Array(Box<MoonBitType>),
    Slice(Box<MoonBitType>),
    Map(Box<MoonBitType>, Box<MoonBitType>),
    Set(Box<MoonBitType>),
    Option(Box<MoonBitType>),
    Result(Box<MoonBitType>, Box<MoonBitType>),
    Tuple(Vec<MoonBitType>),
    Function(Vec<MoonBitType>, Box<MoonBitType>),
    Ref(Box<MoonBitType>),
    MutRef(Box<MoonBitType>),
    Pointer(Box<MoonBitType>),
    Struct(String),
    Enum(String),
    Interface(String),
    Trait(String),
    Error,
    Any,
}

#[derive(Debug, Clone)]
pub struct MoonBitFunction {
    pub name: String,
    pub return_type: MoonBitType,
    pub params: Vec<MoonBitParameter>,
    pub is_pub: bool,
    pub is_test: bool,
    pub is_async: bool,
    pub body: Option<String>,
    pub where_constraints: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct MoonBitParameter {
    pub name: String,
    pub param_type: MoonBitType,
    pub default_value: Option<String>,
}

#[derive(Debug, Clone)]
pub struct MoonBitStruct {
    pub name: String,
    pub fields: Vec<MoonBitField>,
    pub methods: Vec<MoonBitFunction>,
    pub is_pub: bool,
    pub derives: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct MoonBitField {
    pub name: String,
    pub field_type: MoonBitType,
    pub is_mut: bool,
    pub default_value: Option<String>,
}

#[derive(Debug, Clone)]
pub struct MoonBitEnum {
    pub name: String,
    pub variants: Vec<MoonBitVariant>,
    pub methods: Vec<MoonBitFunction>,
    pub is_pub: bool,
    pub derives: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct MoonBitVariant {
    pub name: String,
    pub tag: i64,
    pub associated_type: Option<MoonBitType>,
}

#[derive(Debug, Clone)]
pub struct MoonBitInterface {
    pub name: String,
    pub methods: Vec<MoonBitFunction>,
    pub is_pub: bool,
    pub inherits: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct MoonBitTrait {
    pub name: String,
    pub methods: Vec<MoonBitFunction>,
    pub is_pub: bool,
    pub type_params: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct MoonBitImpl {
    pub name: String,
    pub for_type: String,
    pub methods: Vec<MoonBitFunction>,
    pub is_pub: bool,
    pub type_params: Vec<String>,
    pub where_constraints: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct MoonBitFFIGenerator {
    type_mapping: HashMap<String, MoonBitType>,
    options: MoonBitFFIOptions,
}

#[derive(Debug, Clone)]
pub struct MoonBitFFIOptions {
    pub enable_unsafe: bool,
    pub use_gc: bool,
    pub enable_parallel: bool,
    pub profile: String,
}

impl Default for MoonBitFFIOptions {
    fn default() -> Self {
        Self {
            enable_unsafe: true,
            use_gc: true,
            enable_parallel: true,
            profile: "release".to_string(),
        }
    }
}

impl MoonBitFFIGenerator {
    pub fn new() -> Self {
        let mut generator = Self {
            type_mapping: HashMap::new(),
            options: MoonBitFFIOptions::default(),
        };
        generator.init_type_mapping();
        generator
    }

    fn init_type_mapping(&mut self) {
        self.type_mapping
            .insert("c_void".to_string(), MoonBitType::Unit);
        self.type_mapping
            .insert("c_bool".to_string(), MoonBitType::Bool);
        self.type_mapping
            .insert("c_char".to_string(), MoonBitType::Int8);
        self.type_mapping
            .insert("c_int".to_string(), MoonBitType::Int);
        self.type_mapping
            .insert("c_long".to_string(), MoonBitType::Int64);
        self.type_mapping
            .insert("c_float".to_string(), MoonBitType::Float);
        self.type_mapping
            .insert("c_double".to_string(), MoonBitType::Double);
        self.type_mapping
            .insert("c_string".to_string(), MoonBitType::String);
        self.type_mapping.insert(
            "c_voidptr".to_string(),
            MoonBitType::Pointer(Box::new(MoonBitType::Unit)),
        );
    }

    pub fn generate_moonbit_module(&self, decls: &[MoonBitDeclaration]) -> String {
        let mut output = String::new();

        output.push_str("// MoonBit FFI Module\n");
        output.push_str("// Generated by Chim Compiler\n\n");

        output.push_str("package chim_ffi\n\n");

        if self.options.enable_parallel {
            output.push_str("func pmap[T, U](f: (T) -> U, xs: Array[T]) -> Array[U] {\n");
            output.push_str("    let n = xs.length()\n");
            output.push_str("    let ys = Array::new(n)\n");
            output.push_str("    for i in 0..n {\n");
            output.push_str("        ys[i] = f(xs[i])\n");
            output.push_str("    }\n");
            output.push_str("    ys\n");
            output.push_str("}\n\n");
        }

        for decl in decls {
            match decl {
                MoonBitDeclaration::Struct(s) => self.generate_moonbit_struct(s, &mut output),
                MoonBitDeclaration::Enum(e) => self.generate_moonbit_enum(e, &mut output),
                MoonBitDeclaration::Interface(i) => self.generate_moonbit_interface(i, &mut output),
                MoonBitDeclaration::Trait(t) => self.generate_moonbit_trait(t, &mut output),
                MoonBitDeclaration::Impl(imp) => self.generate_moonbit_impl(imp, &mut output),
                MoonBitDeclaration::Function(f) => self.generate_moonbit_function(f, &mut output),
            }
        }

        output
    }

    fn generate_moonbit_struct(&self, struct_: &MoonBitStruct, output: &mut String) {
        let visibility = if struct_.is_pub { "pub " } else { "" };

        if !struct_.derives.is_empty() {
            output.push_str(&format!("#[derive({})]\n", struct_.derives.join(", ")));
        }

        output.push_str(&format!("{}struct {} {{\n", visibility, struct_.name));

        for field in &struct_.fields {
            self.generate_moonbit_field(field, output);
        }

        output.push_str("}\n\n");

        if !struct_.methods.is_empty() {
            for method in &struct_.methods {
                self.generate_moonbit_function(method, output);
            }
            output.push_str("\n");
        }
    }

    fn generate_moonbit_field(&self, field: &MoonBitField, output: &mut String) {
        let mutability = if field.is_mut { "mut " } else { "" };

        output.push_str(&format!(
            "    {}mut {}: {}",
            mutability,
            field.name,
            self.type_to_string(&field.field_type)
        ));

        if let Some(default) = &field.default_value {
            output.push_str(&format!(" = {}", default));
        }

        output.push_str(",\n");
    }

    fn generate_moonbit_enum(&self, enum_: &MoonBitEnum, output: &mut String) {
        let visibility = if enum_.is_pub { "pub " } else { "" };

        if !enum_.derives.is_empty() {
            output.push_str(&format!("#[derive({})]\n", enum_.derives.join(", ")));
        }

        output.push_str(&format!("{}enum {} {{\n", visibility, enum_.name));

        for variant in &enum_.variants {
            if let Some(ty) = &variant.associated_type {
                output.push_str(&format!(
                    "    | {} of {}\n",
                    variant.name,
                    self.type_to_string(ty)
                ));
            } else {
                output.push_str(&format!("    | {}({})\n", variant.name, variant.tag));
            }
        }

        output.push_str("}\n\n");
    }

    fn generate_moonbit_interface(&self, interface: &MoonBitInterface, output: &mut String) {
        let visibility = if interface.is_pub { "pub " } else { "" };

        output.push_str(&format!("{}interface {} {{\n", visibility, interface.name));

        if !interface.inherits.is_empty() {
            output.push_str(&format!(
                "    // Inherits: {}\n",
                interface.inherits.join(", ")
            ));
        }

        for method in &interface.methods {
            output.push_str(&format!("    fn {}(", method.name));
            let params: Vec<String> = method
                .params
                .iter()
                .map(|p| format!("{}: {}", p.name, self.type_to_string(&p.param_type)))
                .collect();
            output.push_str(&params.join(", "));
            output.push_str(&format!(
                ") -> {}\n",
                self.type_to_string(&method.return_type)
            ));
        }

        output.push_str("}\n\n");
    }

    fn generate_moonbit_trait(&self, trait_: &MoonBitTrait, output: &mut String) {
        let visibility = if trait_.is_pub { "pub " } else { "" };

        output.push_str(&format!("{}trait {}", visibility, trait_.name));

        if !trait_.type_params.is_empty() {
            output.push_str(&format!("[{}]", trait_.type_params.join(", ")));
        }

        output.push_str(" {\n");

        for method in &trait_.methods {
            output.push_str(&format!("    fn {}(", method.name));
            let params: Vec<String> = method
                .params
                .iter()
                .map(|p| format!("{}: {}", p.name, self.type_to_string(&p.param_type)))
                .collect();
            output.push_str(&params.join(", "));
            output.push_str(&format!(
                ") -> {}\n",
                self.type_to_string(&method.return_type)
            ));
        }

        output.push_str("}\n\n");
    }

    fn generate_moonbit_impl(&self, imp: &MoonBitImpl, output: &mut String) {
        let visibility = if imp.is_pub { "pub " } else { "" };

        output.push_str(&format!(
            "{}impl {} for {}",
            visibility, imp.name, imp.for_type
        ));

        if !imp.type_params.is_empty() {
            output.push_str(&format!("[{}]", imp.type_params.join(", ")));
        }

        if !imp.where_constraints.is_empty() {
            output.push_str(&format!(" where {}", imp.where_constraints.join(", ")));
        }

        output.push_str(" {\n");

        for method in &imp.methods {
            self.generate_moonbit_function(method, output);
        }

        output.push_str("}\n\n");
    }

    fn generate_moonbit_function(&self, func: &MoonBitFunction, output: &mut String) {
        let visibility = if func.is_pub { "pub " } else { "" };
        let test = if func.is_test { "test " } else { "" };

        output.push_str(&format!("{}fn {}(", visibility, func.name));

        let params: Vec<String> = func
            .params
            .iter()
            .map(|p| self.format_parameter(p))
            .collect();
        output.push_str(&params.join(", "));
        output.push_str(&format!(") -> {}", self.type_to_string(&func.return_type)));

        if let Some(body) = &func.body {
            output.push_str(" {\n");
            output.push_str("    ");
            output.push_str(body.replace("\n", "\n    "));
            output.push_str("\n}\n\n");
        } else {
            output.push_str(" {\n");
            output.push_str("    ()\n");
            output.push_str("}\n\n");
        }
    }

    fn format_parameter(&self, param: &MoonBitParameter) -> String {
        format!("{}: {}", param.name, self.type_to_string(&param.param_type))
    }

    fn type_to_string(&self, ty: &MoonBitType) -> String {
        match ty {
            MoonBitType::Unit => "Unit".to_string(),
            MoonBitType::Bool => "Bool".to_string(),
            MoonBitType::Int => "Int".to_string(),
            MoonBitType::Int8 => "Int8".to_string(),
            MoonBitType::Int16 => "Int16".to_string(),
            MoonBitType::Int32 => "Int32".to_string(),
            MoonBitType::Int64 => "Int64".to_string(),
            MoonBitType::UInt => "UInt".to_string(),
            MoonBitType::UInt8 => "UInt8".to_string(),
            MoonBitType::UInt16 => "UInt16".to_string(),
            MoonBitType::UInt32 => "UInt32".to_string(),
            MoonBitType::UInt64 => "UInt64".to_string(),
            MoonBitType::Float => "Float".to_string(),
            MoonBitType::Double => "Double".to_string(),
            MoonBitType::String => "String".to_string(),
            MoonBitType::Bytes => "Bytes".to_string(),
            MoonBitType::Array(inner) => format!("Array[{}]", self.type_to_string(inner)),
            MoonBitType::Slice(inner) => format!("Slice[{}]", self.type_to_string(inner)),
            MoonBitType::Map(key, value) => {
                format!(
                    "Map[{}, {}]",
                    self.type_to_string(key),
                    self.type_to_string(value)
                )
            }
            MoonBitType::Set(inner) => format!("Set[{}]", self.type_to_string(inner)),
            MoonBitType::Option(inner) => format!("Option[{}]", self.type_to_string(inner)),
            MoonBitType::Result(ok, err) => {
                format!(
                    "Result[{}, {}]",
                    self.type_to_string(ok),
                    self.type_to_string(err)
                )
            }
            MoonBitType::Tuple(types) => {
                let type_strs: Vec<String> = types.iter().map(|t| self.type_to_string(t)).collect();
                format!("({})", type_strs.join(", "))
            }
            MoonBitType::Function(params, ret) => {
                let param_strs: Vec<String> =
                    params.iter().map(|t| self.type_to_string(t)).collect();
                format!(
                    "fn({}) -> {}",
                    param_strs.join(", "),
                    self.type_to_string(ret)
                )
            }
            MoonBitType::Ref(inner) => format!("&{}", self.type_to_string(inner)),
            MoonBitType::MutRef(inner) => format!("&mut {}", self.type_to_string(inner)),
            MoonBitType::Pointer(inner) => format!("*{}", self.type_to_string(inner)),
            MoonBitType::Struct(name) => name.clone(),
            MoonBitType::Enum(name) => name.clone(),
            MoonBitType::Interface(name) => name.clone(),
            MoonBitType::Trait(name) => format!("{}Trait", name),
            MoonBitType::Error => "Error".to_string(),
            MoonBitType::Any => "Any".to_string(),
        }
    }

    pub fn set_options(&mut self, options: MoonBitFFIOptions) {
        self.options = options;
    }
}

#[derive(Debug, Clone)]
pub enum MoonBitDeclaration {
    Struct(MoonBitStruct),
    Enum(MoonBitEnum),
    Interface(MoonBitInterface),
    Trait(MoonBitTrait),
    Impl(MoonBitImpl),
    Function(MoonBitFunction),
}

pub fn map_chim_type_to_moonbit(chim_type: &crate::Type) -> MoonBitType {
    match chim_type {
        crate::Type::CVoid => MoonBitType::Unit,
        crate::Type::CBool => MoonBitType::Bool,
        crate::Type::CChar => MoonBitType::Int8,
        crate::Type::CShort => MoonBitType::Int16,
        crate::Type::CInt => MoonBitType::Int,
        crate::Type::CLong => MoonBitType::Int64,
        crate::Type::CLongLong => MoonBitType::Int64,
        crate::Type::CUChar => MoonBitType::UInt8,
        crate::Type::CUShort => MoonBitType::UInt16,
        crate::Type::CUInt => MoonBitType::UInt,
        crate::Type::CULong => MoonBitType::UInt64,
        crate::Type::CULongLong => MoonBitType::UInt64,
        crate::Type::CFloat => MoonBitType::Float,
        crate::Type::CDouble => MoonBitType::Double,
        crate::Type::CStr => MoonBitType::String,
        crate::Type::CVoidPtr => MoonBitType::Pointer(Box::new(MoonBitType::Unit)),
        crate::Type::ISize => MoonBitType::Int,
        crate::Type::USize => MoonBitType::UInt,
        crate::Type::Pointer { target, .. } => {
            MoonBitType::Pointer(Box::new(map_chim_type_to_moonbit(target)))
        }
        crate::Type::Array { element, length: _ } => {
            MoonBitType::Array(Box::new(map_chim_type_to_moonbit(element)))
        }
        crate::Type::Function { params, ret, .. } => {
            let param_types: Vec<MoonBitType> =
                params.iter().map(|p| map_chim_type_to_moonbit(p)).collect();
            let ret_type = Box::new(map_chim_type_to_moonbit(ret));
            MoonBitType::Function(param_types, ret_type)
        }
        crate::Type::Struct { name, .. } => MoonBitType::Struct(name.to_string()),
        _ => MoonBitType::Any,
    }
}
