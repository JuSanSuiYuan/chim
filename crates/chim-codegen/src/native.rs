use crate::{CodegenTarget, CodeGenerator, GeneratedCode, CodegenError};
use chim_ir::{IRModule, IRFunction, IRInst, BinaryOp, Terminator};
use chim_semantic::AnalyzedProgram;
use chim_span::Span;

pub struct NativeCodeGenerator;

impl NativeCodeGenerator {
    pub fn new() -> Self {
        NativeCodeGenerator
    }
}

impl CodeGenerator for NativeCodeGenerator {
    fn generate(&self, module: &IRModule, _program: &AnalyzedProgram) -> Result<GeneratedCode, CodegenError> {
        let mut output = String::new();

        output.push_str("; Native code generation for x86_64\n");
        output.push_str("; Generated by Chim Compiler\n\n");

        for func in &module.functions {
            output.push_str(&format!("; Function: {}\n", func.name));
            output.push_str(&format!("; Parameters: {}\n", func.params.len()));
            output.push_str("\n");

            for block in &func.body {
                output.push_str(&format!("; Block {}\n", block.id.0));

                for inst in &block.instructions {
                    match inst {
                        IRInst::AtomicLoad { dest, src, order, ty, span } => {
                            output.push_str(&format!("  atomic.load {:?}, {:?}, {:?}, {:?}\n", dest, src, order, ty));
                        }
                        IRInst::AtomicStore { dest, src, order, ty, span } => {
                            output.push_str(&format!("  atomic.store {:?}, {:?}, {:?}, {:?}\n", dest, src, order, ty));
                        }
                        IRInst::AtomicFetchAdd { dest, src, value, order, ty, span } => {
                            output.push_str(&format!("  atomic.fetch_add {:?}, {:?}, {:?}, {:?}, {:?}\n", dest, src, value, order, ty));
                        }
                        IRInst::AtomicFetchSub { dest, src, value, order, ty, span } => {
                            output.push_str(&format!("  atomic.fetch_sub {:?}, {:?}, {:?}, {:?}, {:?}\n", dest, src, value, order, ty));
                        }
                        IRInst::AtomicFetchAnd { dest, src, value, order, ty, span } => {
                            output.push_str(&format!("  atomic.fetch_and {:?}, {:?}, {:?}, {:?}, {:?}\n", dest, src, value, order, ty));
                        }
                        IRInst::AtomicFetchOr { dest, src, value, order, ty, span } => {
                            output.push_str(&format!("  atomic.fetch_or {:?}, {:?}, {:?}, {:?}, {:?}\n", dest, src, value, order, ty));
                        }
                        IRInst::AtomicFetchXor { dest, src, value, order, ty, span } => {
                            output.push_str(&format!("  atomic.fetch_xor {:?}, {:?}, {:?}, {:?}, {:?}\n", dest, src, value, order, ty));
                        }
                        IRInst::AtomicCompareExchange { dest, src, expected, desired, success_order, failure_order, ty, span } => {
                            output.push_str(&format!("  atomic.compare_exchange {:?}, {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\n", dest, src, expected, desired, success_order, failure_order, ty));
                        }
                        IRInst::AtomicExchange { dest, src, value, order, ty, span } => {
                            output.push_str(&format!("  atomic.exchange {:?}, {:?}, {:?}, {:?}, {:?}\n", dest, src, value, order, ty));
                        }
                        IRInst::AtomicFence { order, span } => {
                            output.push_str(&format!("  atomic.fence {:?}\n", order));
                        }
                        IRInst::Wait { atomic, timeout, span } => {
                            output.push_str(&format!("  wait {:?}, {:?}\n", atomic, timeout));
                        }
                        IRInst::Notify { atomic, span } => {
                            output.push_str(&format!("  notify {:?}\n", atomic));
                        }
                        IRInst::NotifyAll { atomic, span } => {
                            output.push_str(&format!("  notify_all {:?}\n", atomic));
                        }
                        IRInst::MemoryBarrier { span } => {
                            output.push_str("  memory_barrier\n");
                        }
                        IRInst::DataDependency { src, dest, span } => {
                            output.push_str(&format!("  data_dependency {:?}, {:?}\n", src, dest));
                        }
                        IRInst::MacroExpand { dest, macro_name, args, span } => {
                            output.push_str(&format!("  macro.expand {:?}, {:?}, {:?}\n", dest, macro_name, args));
                        }
                        IRInst::ClosureCreate { dest, params, body, captures, span } => {
                            output.push_str(&format!("  closure.create {:?}, {:?}, {:?}, {:?}\n", dest, params, body, captures));
                        }
                        IRInst::IteratorNext { dest, iterator, span } => {
                            output.push_str(&format!("  iterator.next {:?}, {:?}\n", dest, iterator));
                        }
                        IRInst::IteratorCollect { dest, iterator, span } => {
                            output.push_str(&format!("  iterator.collect {:?}, {:?}\n", dest, iterator));
                        }
                        IRInst::IteratorChain { dest, iterator1, iterator2, span } => {
                            output.push_str(&format!("  iterator.chain {:?}, {:?}, {:?}\n", dest, iterator1, iterator2));
                        }
                        IRInst::IteratorFilter { dest, iterator, predicate, span } => {
                            output.push_str(&format!("  iterator.filter {:?}, {:?}, {:?}\n", dest, iterator, predicate));
                        }
                        IRInst::IteratorFold { dest, iterator, init, accumulator, body, span } => {
                            output.push_str(&format!("  iterator.fold {:?}, {:?}, {:?}, {:?}, {:?}\n", dest, iterator, init, accumulator, body));
                        }
                        IRInst::IteratorMap { dest, iterator, mapper, span } => {
                            output.push_str(&format!("  iterator.map {:?}, {:?}, {:?}\n", dest, iterator, mapper));
                        }
                        IRInst::ResultOk { dest, value, ok_type, err_type, span } => {
                            output.push_str(&format!("  result.ok {:?}, {:?}, {:?}, {:?}\n", dest, value, ok_type, err_type));
                        }
                        IRInst::ResultErr { dest, error, ok_type, err_type, span } => {
                            output.push_str(&format!("  result.err {:?}, {:?}, {:?}, {:?}\n", dest, error, ok_type, err_type));
                        }
                        IRInst::TryCatch { dest, try_expr, catch_block, error_var, span } => {
                            output.push_str(&format!("  try_catch {:?}, {:?}, {:?}, {:?}\n", dest, try_expr, catch_block, error_var));
                        }
                        IRInst::Throw { error, span } => {
                            output.push_str(&format!("  throw {:?}\n", error));
                        }
                        IRInst::FutureAwait { dest, future, span } => {
                            output.push_str(&format!("  future.await {:?}, {:?}\n", dest, future));
                        }
                        IRInst::Yield { value, span } => {
                            output.push_str(&format!("  yield {:?}\n", value));
                        }
                        IRInst::StreamYield { value, span } => {
                            output.push_str(&format!("  stream_yield {:?}\n", value));
                        }
                        _ => {
                            output.push_str(&format!("  ; {:?}\n", inst));
                        }
                    }
                }

                match &block.terminator {
                    Terminator::Return(value) => {
                        if let Some(v) = value {
                            output.push_str(&format!("  ret {:?}\n", v));
                        } else {
                            output.push_str("  ret\n");
                        }
                    }
                    Terminator::Branch(target) => {
                        output.push_str(&format!("  jmp .L{}\n", target.0));
                    }
                    Terminator::ConditionalBranch { condition, true_block, false_block } => {
                        output.push_str(&format!("  jne {:?}, .L{}, .L{}\n", condition, true_block.0, false_block.0));
                    }
                    Terminator::Unreachable => {
                        output.push_str("  ud2\n");
                    }
                    Terminator::Invoke { func, args, normal_block, unwind_block } => {
                        output.push_str(&format!("  invoke {:?}, {:?}, .L{}, .L{}\n", func, args, normal_block.0, unwind_block.0));
                    }
                    Terminator::Switch { value, default_block, cases } => {
                        output.push_str(&format!("  switch {:?}, .L{}\n", value, default_block.0));
                        for (case_value, case_block) in cases {
                            output.push_str(&format!("    case {:?} -> .L{}\n", case_value, case_block.0));
                        }
                    }
                }

                output.push_str("\n");
            }

            output.push_str("\n");
        }

        Ok(GeneratedCode {
            source: output,
            extension: String::from("asm"),
            language: String::from("Assembly (x86_64)"),
            is_executable: false,
        })
    }

    fn name(&self) -> &str {
        "Native (x86_64)"
    }

    fn file_extension(&self) -> &str {
        "asm"
    }

    fn target(&self) -> CodegenTarget {
        CodegenTarget::Native
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_native_generator() {
        let generator = NativeCodeGenerator::new();
        assert_eq!(generator.name(), "Native (x86_64)");
        assert_eq!(generator.file_extension(), "asm");
    }
}
