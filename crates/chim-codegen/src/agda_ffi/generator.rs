use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AgdaType {
    Unit,
    Bool,
    Nat,
    Integer,
    Float,
    String,
    Char,
    List(Box<AgdaType>),
    Vec(Box<AgdaType>),
    Maybe(Box<AgdaType>),
    Either(Box<AgdaType>, Box<AgdaType>),
    Tuple(Vec<AgdaType>),
    Record(String),
    Data(String),
    Set(Box<AgdaType>),
    IO(Box<AgdaType>),
    Ref(Box<AgdaType>),
    Pointer(Box<AgdaType>),
    Any,
}

#[derive(Debug, Clone)]
pub struct AgdaFunction {
    pub name: String,
    pub return_type: AgdaType,
    pub params: Vec<AgdaParameter>,
    pub is_pub: bool,
    pub is_termination_checked: bool,
    pub is_total: bool,
    pub postulates: Vec<String>,
    pub body: Option<String>,
}

#[derive(Debug, Clone)]
pub struct AgdaParameter {
    pub name: String,
    pub param_type: AgdaType,
    pub implicit: bool,
}

#[derive(Debug, Clone)]
pub struct AgdaData {
    pub name: String,
    pub type_params: Vec<String>,
    pub constructors: Vec<AgdaConstructor>,
    pub is_pub: bool,
    pub is_inductive: bool,
}

#[derive(Debug, Clone)]
pub struct AgdaConstructor {
    pub name: String,
    pub fields: Vec<AgdaField>,
}

#[derive(Debug, Clone)]
pub struct AgdaField {
    pub name: String,
    pub field_type: AgdaType,
    pub implicit: bool,
}

#[derive(Debug, Clone)]
pub struct AgdaRecord {
    pub name: String,
    pub type_params: Vec<String>,
    pub fields: Vec<AgdaField>,
    pub is_pub: bool,
}

#[derive(Debug, Clone)]
pub struct AgdaModule {
    pub name: String,
    pub imports: Vec<String>,
    pub open_imports: Vec<String>,
    pub declarations: Vec<AgdaDeclaration>,
}

#[derive(Debug, Clone)]
pub enum AgdaDeclaration {
    Data(AgdaData),
    Record(AgdaRecord),
    Function(AgdaFunction),
    Postulate(AgdaFunction),
}

#[derive(Debug, Clone)]
pub struct AgdaFFIGenerator {
    type_mapping: HashMap<String, AgdaType>,
    builtin_types: Vec<String>,
}

impl AgdaFFIGenerator {
    pub fn new() -> Self {
        let mut generator = Self {
            type_mapping: HashMap::new(),
            builtin_types: vec![
                "Agda.Builtin.Nat".to_string(),
                "Agda.Builtin.Integer".to_string(),
                "Agda.Builtin.Float".to_string(),
                "Agda.Builtin.Bool".to_string(),
                "Agda.Builtin.String".to_string(),
                "Agda.Builtin.Char".to_string(),
                "Agda.Builtin.Unit".to_string(),
                "Agda.Builtin.List".to_string(),
                "Agda.Builtin.Maybe".to_string(),
                "Agda.Builtin.IO".to_string(),
            ],
        };
        generator.init_type_mapping();
        generator
    }

    fn init_type_mapping(&mut self) {
        self.type_mapping
            .insert("c_void".to_string(), AgdaType::Unit);
        self.type_mapping
            .insert("c_bool".to_string(), AgdaType::Bool);
        self.type_mapping
            .insert("c_int".to_string(), AgdaType::Integer);
        self.type_mapping
            .insert("c_long".to_string(), AgdaType::Integer);
        self.type_mapping
            .insert("c_float".to_string(), AgdaType::Float);
        self.type_mapping
            .insert("c_double".to_string(), AgdaType::Float);
        self.type_mapping
            .insert("c_string".to_string(), AgdaType::String);
        self.type_mapping
            .insert("c_voidptr".to_string(), AgdaType::Pointer(Box::new(AgdaType::Unit)));
    }

    pub fn generate_agda_module(&self, module: &AgdaModule) -> String {
        let mut output = String::new();

        output.push_str("-- Agda FFI Module\n");
        output.push_str("-- Generated by Chim Compiler\n\n");

        output.push_str(&format!("module {} where\n\n", module.name));

        for import in &module.imports {
            output.push_str(&format!("open import {}\n", import));
        }

        for open_import in &module.open_imports {
            output.push_str(&format!("open import {} using ()\n", open_import));
        }

        output.push_str("\n");

        for decl in &module.declarations {
            match decl {
                AgdaDeclaration::Data(d) => self.generate_agda_data(d, &mut output),
                AgdaDeclaration::Record(r) => self.generate_agda_record(r, &mut output),
                AgdaDeclaration::Function(f) => self.generate_agda_function(f, &mut output),
                AgdaDeclaration::Postulate(p) => self.generate_agda_postulate(p, &mut output),
            }
        }

        output
    }

    fn generate_agda_data(&self, data: &AgdaData, output: &mut String) {
        let visibility = if data.is_pub { "" } else { "private " };

        output.push_str(&format!("{}data {}", visibility, data.name));

        if !data.type_params.is_empty() {
            output.push_str(&format!(" ({})", data.type_params.join(" ")));
        }

        output.push_str(" : Set where\n");

        for constructor in &data.constructors {
            self.generate_agda_constructor(constructor, output);
        }

        output.push_str("\n");
    }

    fn generate_agda_constructor(&self, constructor: &AgdaConstructor, output: &mut String) {
        output.push_str(&format!("  | {} ", constructor.name));

        for field in &constructor.fields {
            if field.implicit {
                output.push_str(&format!("{{{} : ", field.name));
            } else {
                output.push_str(&format!("({} : ", field.name));
            }
            output.push_str(&self.type_to_string(&field.field_type));
            if field.implicit {
                output.push_str("}) ");
            } else {
                output.push_str(") ");
            }
        }

        output.push_str("\n");
    }

    fn generate_agda_record(&self, record: &AgdaRecord, output: &mut String) {
        let visibility = if record.is_pub { "" } else { "private " };

        output.push_str(&format!("{}record {} ", visibility, record.name));

        if !record.type_params.is_empty() {
            output.push_str(&format!("({}) : Set where\n", record.type_params.join(" ")));
        } else {
            output.push_str(": Set where\n");
        }

        output.push_str("  constructor\n");
        output.push_str(&format!("    field\n"));

        for field in &record.fields {
            output.push_str(&format!("      {} : ", field.name));
            output.push_str(&self.type_to_string(&field.field_type));
            output.push_str("\n");
        }

        output.push_str("\n");
    }

    fn generate_agda_function(&self, func: &AgdaFunction, output: &mut String) {
        let visibility = if func.is_pub { "" } else { "private " };

        if func.is_termination_checked {
            output.push_str(&format!("{}{} : ", visibility, func.name));
        } else {
            output.push_str(&format!("{}{-# NON_TERMINATING #-}\n", visibility));
            output.push_str(&format!("{}{} : ", visibility, func.name));
        }

        for param in &func.params {
            if param.implicit {
                output.push_str(&format!("{{{} : ", param.name));
            } else {
                output.push_str(&format!("({} : ", param.name));
            }
            output.push_str(&self.type_to_string(&param.param_type));
            if param.implicit {
                output.push_str("}) ");
            } else {
                output.push_str(") ");
            }
        }

        output.push_str(&format!("→ {}\n", self.type_to_string(&func.return_type)));

        if let Some(body) = &func.body {
            output.push_str(&format!("{}  {}\n\n", func.name, body));
        } else {
            output.push_str(&format!("{}  = ?\n\n", func.name));
        }
    }

    fn generate_agda_postulate(&self, func: &AgdaFunction, output: &mut String) {
        let visibility = if func.is_pub { "" } else { "private " };

        output.push_str(&format!("{}postulate\n", visibility));
        output.push_str(&format!("  {} : ", func.name));

        for param in &func.params {
            if param.implicit {
                output.push_str(&format!("{{{} : ", param.name));
            } else {
                output.push_str(&format!("({} : ", param.name));
            }
            output.push_str(&self.type_to_string(&param.param_type));
            if param.implicit {
                output.push_str("}) ");
            } else {
                output.push_str(") ");
            }
        }

        output.push_str(&format!("→ {}\n\n", self.type_to_string(&func.return_type)));
    }

    fn type_to_string(&self, ty: &AgdaType) -> String {
        match ty {
            AgdaType::Unit => "⊤".to_string(),
            AgdaType::Bool => "Bool".to_string(),
            AgdaType::Nat => "Nat".to_string(),
            AgdaType::Integer => "Integer".to_string(),
            AgdaType::Float => "Float".to_string(),
            AgdaType::String => "String".to_string(),
            AgdaType::Char => "Char".to_string(),
            AgdaType::List(inner) => format!("List {}", self.type_to_string(inner)),
            AgdaType::Vec(inner) => format!("Vec {}", self.type_to_string(inner)),
            AgdaType::Maybe(inner) => format!("Maybe {}", self.type_to_string(inner)),
            AgdaType::Either(left, right) => {
                format!(
                    "Either {} {}",
                    self.type_to_string(left),
                    self.type_to_string(right)
                )
            }
            AgdaType::Tuple(types) => {
                let type_strs: Vec<String> = types.iter().map(|t| self.type_to_string(t)).collect();
                format!("({})", type_strs.join(" × "))
            }
            AgdaType::Record(name) => name.clone(),
            AgdaType::Data(name) => name.clone(),
            AgdaType::Set(inner) => format!("Set {}", self.type_to_string(inner)),
            AgdaType::IO(inner) => format!("IO {}", self.type_to_string(inner)),
            AgdaType::Ref(inner) => format!("Ref {}", self.type_to_string(inner)),
            AgdaType::Pointer(inner) => format!("Ptr {}", self.type_to_string(inner)),
            AgdaType::Any => "Set".to_string(),
        }
    }

    pub fn add_builtin_type(&mut self, type_name: String) {
        if !self.builtin_types.contains(&type_name) {
            self.builtin_types.push(type_name);
        }
    }
}

pub fn map_chim_type_to_agda(chim_type: &crate::Type) -> AgdaType {
    match chim_type {
        crate::Type::CVoid => AgdaType::Unit,
        crate::Type::CBool => AgdaType::Bool,
        crate::Type::CChar => AgdaType::Char,
        crate::Type::CInt => AgdaType::Integer,
        crate::Type::CLong => AgdaType::Integer,
        crate::Type::CLongLong => AgdaType::Integer,
        crate::Type::CUChar => AgdaType::Nat,
        crate::Type::CUShort => AgdaType::Nat,
        crate::Type::CUInt => AgdaType::Nat,
        crate::Type::CULong => AgdaType::Nat,
        crate::Type::CULongLong => AgdaType::Nat,
        crate::Type::CFloat => AgdaType::Float,
        crate::Type::CDouble => AgdaType::Float,
        crate::Type::CStr => AgdaType::String,
        crate::Type::CVoidPtr => AgdaType::Pointer(Box::new(AgdaType::Unit)),
        crate::Type::ISize => AgdaType::Integer,
        crate::Type::USize => AgdaType::Nat,
        crate::Type::Pointer { target, .. } => {
            AgdaType::Pointer(Box::new(map_chim_type_to_agda(target)))
        }
        crate::Type::Array { element, length: _ } => {
            AgdaType::Vec(Box::new(map_chim_type_to_agda(element)))
        }
        crate::Type::Function { params, ret, .. } => {
            let param_types: Vec<AgdaType> =
                params.iter().map(|p| map_chim_type_to_agda(p)).collect();
            let ret_type = Box::new(map_chim_type_to_agda(ret));
            AgdaType::Function(param_types, ret_type)
        }
        crate::Type::Struct { name, .. } => AgdaType::Record(name.to_string()),
        _ => AgdaType::Any,
    }
}
