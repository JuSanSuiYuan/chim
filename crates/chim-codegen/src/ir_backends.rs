use crate::{CodegenTarget, CodeGenerator, GeneratedCode, CodegenError};
use chim_ir::IRModule;
use chim_semantic::AnalyzedProgram;

pub struct LLVMCodeGenerator;

impl LLVMCodeGenerator {
    pub fn new() -> Self {
        LLVMCodeGenerator
    }
}

impl CodeGenerator for LLVMCodeGenerator {
    fn generate(&self, module: &IRModule, _program: &AnalyzedProgram) -> Result<GeneratedCode, CodegenError> {
        let mut output = String::new();

        output.push_str("; LLVM IR generation\n");
        output.push_str("; Generated by Chim Compiler\n\n");

        for func in &module.functions {
            output.push_str(&format!("define i32 @{}(", func.name));

            let params: Vec<String> = func.params.iter()
                .map(|p| format!("i32 %{}", p.name))
                .collect();
            output.push_str(&params.join(", "));
            output.push_str(") {\n");

            for block in &func.body {
                output.push_str(&format!(".L{}:\n", block.id.0));

                for inst in &block.instructions {
                    output.push_str(&format!("  ; {:?}\n", inst));
                }

                output.push_str("\n");
            }

            output.push_str("}\n\n");
        }

        Ok(GeneratedCode {
            source: output,
            extension: String::from("ll"),
            language: String::from("LLVM IR"),
            is_executable: false,
        })
    }

    fn name(&self) -> &str {
        "LLVM IR"
    }

    fn file_extension(&self) -> &str {
        "ll"
    }

    fn target(&self) -> CodegenTarget {
        CodegenTarget::LLVM
    }
}

pub struct CraneliftCodeGenerator;

impl CraneliftCodeGenerator {
    pub fn new() -> Self {
        CraneliftCodeGenerator
    }
}

impl CodeGenerator for CraneliftCodeGenerator {
    fn generate(&self, module: &IRModule, _program: &AnalyzedProgram) -> Result<GeneratedCode, CodegenError> {
        let mut output = String::new();

        output.push_str("; Cranelift IR generation\n");
        output.push_str("; Generated by Chim Compiler\n\n");

        for func in &module.functions {
            output.push_str(&format!("function u0:{}(", func.name));

            let params: Vec<String> = func.params.iter()
                .map(|p| format!("i64 %{}", p.name))
                .collect();
            output.push_str(&params.join(", "));
            output.push_str(") {\n");
            output.push_str("}\n\n");
        }

        Ok(GeneratedCode {
            source: output,
            extension: String::from("clif"),
            language: String::from("Cranelift IR"),
            is_executable: false,
        })
    }

    fn name(&self) -> &str {
        "Cranelift IR"
    }

    fn file_extension(&self) -> &str {
        "clif"
    }

    fn target(&self) -> CodegenTarget {
        CodegenTarget::Cranelift
    }
}

pub struct QBECodeGenerator;

impl QBECodeGenerator {
    pub fn new() -> Self {
        QBECodeGenerator
    }
}

impl CodeGenerator for QBECodeGenerator {
    fn generate(&self, module: &IRModule, _program: &AnalyzedProgram) -> Result<GeneratedCode, CodegenError> {
        let mut output = String::new();

        output.push_str("# QBE IR generation\n");
        output.push_str("# Generated by Chim Compiler\n\n");

        output.push_str("export function w $main() {\n");
        output.push_str("@start\n");
        output.push_str("    ret 0\n");
        output.push_str("}\n");

        Ok(GeneratedCode {
            source: output,
            extension: String::from("qbe"),
            language: String::from("QBE IL"),
            is_executable: false,
        })
    }

    fn name(&self) -> &str {
        "QBE"
    }

    fn file_extension(&self) -> &str {
        "qbe"
    }

    fn target(&self) -> CodegenTarget {
        CodegenTarget::QBE
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_llvm_generator() {
        let generator = LLVMCodeGenerator::new();
        assert_eq!(generator.name(), "LLVM IR");
        assert_eq!(generator.file_extension(), "ll");
    }

    #[test]
    fn test_cranelift_generator() {
        let generator = CraneliftCodeGenerator::new();
        assert_eq!(generator.name(), "Cranelift IR");
        assert_eq!(generator.file_extension(), "clif");
    }

    #[test]
    fn test_qbe_generator() {
        let generator = QBECodeGenerator::new();
        assert_eq!(generator.name(), "QBE");
        assert_eq!(generator.file_extension(), "qbe");
    }
}
