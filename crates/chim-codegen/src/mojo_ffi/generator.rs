use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MojoType {
    Void,
    Bool,
    Int,
    Int8,
    Int16,
    Int32,
    Int64,
    UInt,
    UInt8,
    UInt16,
    UInt32,
    UInt64,
    Float32,
    Float64,
    String,
    Array(Box<MojoType>),
    SIMD(Box<MojoType>, usize),
    Tensor,
    Pointer(Box<MojoType>),
    Reference(Box<MojoType>),
    Fn,
    Struct(String),
    Trait(String),
    AnyType,
}

#[derive(Debug, Clone)]
pub struct MojoFunction {
    pub name: String,
    pub return_type: MojoType,
    pub params: Vec<MojoParameter>,
    pub is_pythonic: bool,
    pub is_inline: bool,
    pub is_param: bool,
    pub body: Option<String>,
    pub raises: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct MojoParameter {
    pub name: String,
    pub param_type: MojoType,
    pub is_inout: bool,
    pub default_value: Option<String>,
}

#[derive(Debug, Clone)]
pub struct MojoStruct {
    pub name: String,
    pub fields: Vec<MojoField>,
    pub methods: Vec<MojoFunction>,
    pub is_copyable: bool,
    pub is_movable: bool,
    pub field_types: Vec<(String, MojoType)>,
}

#[derive(Debug, Clone)]
pub struct MojoField {
    pub name: String,
    pub field_type: MojoType,
    pub default_value: Option<String>,
}

#[derive(Debug, Clone)]
pub struct MojoTrait {
    pub name: String,
    pub methods: Vec<MojoFunction>,
    pub constraints: Vec<MojoType>,
}

#[derive(Debug, Clone)]
pub struct MojoSIMDOperation {
    pub operation: String,
    pub dtype: MojoType,
    pub width: usize,
}

#[derive(Debug, Clone)]
pub struct MojoFFIGenerator {
    type_mapping: HashMap<String, MojoType>,
    imports: Vec<String>,
    options: MojoFFIOptions,
}

#[derive(Debug, Clone)]
pub struct MojoFFIOptions {
    pub use_gpu: bool,
    pub simd_width: usize,
    pub use_tensor_api: bool,
    pub enable_vectorization: bool,
    pub use_mlir_backend: bool,
}

impl Default for MojoFFIOptions {
    fn default() -> Self {
        Self {
            use_gpu: true,
            simd_width: 8,
            use_tensor_api: true,
            enable_vectorization: true,
            use_mlir_backend: true,
        }
    }
}

impl MojoFFIGenerator {
    pub fn new() -> Self {
        let mut generator = Self {
            type_mapping: HashMap::new(),
            imports: Vec::new(),
            options: MojoFFIOptions::default(),
        };
        generator.init_type_mapping();
        generator
    }

    fn init_type_mapping(&mut self) {
        self.type_mapping
            .insert("c_void".to_string(), MojoType::Void);
        self.type_mapping
            .insert("c_bool".to_string(), MojoType::Bool);
        self.type_mapping
            .insert("c_char".to_string(), MojoType::Int8);
        self.type_mapping.insert("c_int".to_string(), MojoType::Int);
        self.type_mapping
            .insert("c_long".to_string(), MojoType::Int);
        self.type_mapping
            .insert("c_float".to_string(), MojoType::Float32);
        self.type_mapping
            .insert("c_double".to_string(), MojoType::Float64);
        self.type_mapping
            .insert("c_string".to_string(), MojoType::String);
        self.type_mapping.insert(
            "c_voidptr".to_string(),
            MojoType::Pointer(Box::new(MojoType::Void)),
        );
    }

    pub fn generate_mojo_module(&self, decls: &[MojoDeclaration]) -> String {
        let mut output = String::new();

        output.push_str("# Mojo FFI Module\n");
        output.push_str("# Generated by Chim Compiler\n\n");

        output.push_str("from memory import UnsafePointer, DTypePointer\n");
        output.push_str("from math import sqrt, sin, cos, exp, log\n");
        output.push_str("from algorithm import vectorize, parallelize\n");

        if self.options.use_tensor_api {
            output.push_str("from tensor import Tensor\n");
        }

        if self.options.use_gpu {
            output.push_str("from gpu import Device, thread_id, block_id, block_size\n\n");
        } else {
            output.push_str("\n");
        }

        output.push_str("# SIMD Configuration\n");
        output.push_str(&format!("alias simd_width = {}\n", self.options.simd_width));
        output.push_str("alias float32_simd = SIMD[DType.float32, simd_width]\n");
        output.push_str("alias float64_simd = SIMD[DType.float64, simd_width]\n");
        output.push_str("alias int32_simd = SIMD[DType.int32, simd_width]\n\n");

        for decl in decls {
            match decl {
                MojoDeclaration::Struct(s) => self.generate_mojo_struct(s, &mut output),
                MojoDeclaration::Trait(t) => self.generate_mojo_trait(t, &mut output),
                MojoDeclaration::Function(f) => self.generate_mojo_function(f, &mut output),
            }
        }

        output
    }

    fn generate_mojo_struct(&self, struct_: &MojoStruct, output: &mut String) {
        output.push_str(&format!("struct {}:\n", struct_.name));

        for field in &struct_.fields {
            self.generate_mojo_field(field, output);
        }

        if !struct_.methods.is_empty() {
            output.push_str("\n");
            for method in &struct_.methods {
                self.generate_mojo_method(method, output);
            }
        }

        output.push_str("\n");
    }

    fn generate_mojo_field(&self, field: &MojoField, output: &mut String) {
        output.push_str(&format!(
            "    var {}: {}",
            field.name,
            self.type_to_string(&field.field_type)
        ));

        if let Some(default) = &field.default_value {
            output.push_str(&format!(" = {}", default));
        }

        output.push_str("\n");
    }

    fn generate_mojo_function(&self, func: &MojoFunction, output: &mut String) {
        if func.is_param {
            output.push_str("@parameter\n");
        }

        if func.is_inline {
            output.push_str("@always_inline\n");
        }

        output.push_str("fn ");
        output.push_str(&func.name);
        output.push_str("(");

        let params: Vec<String> = func
            .params
            .iter()
            .map(|p| self.format_parameter(p))
            .collect();
        output.push_str(&params.join(", "));
        output.push_str(") -> ");
        output.push_str(&self.type_to_string(&func.return_type));

        if !func.raises.is_empty() {
            output.push_str(&format!(" raises {}", func.raises.join(", ")));
        }

        if let Some(body) = &func.body {
            output.push_str(":\n");
            output.push_str("    ");
            output.push_str(body);
            output.push_str("\n");
        } else {
            output.push_str(":\n");
            output.push_str("    pass\n");
        }

        output.push_str("\n");
    }

    fn generate_mojo_method(&self, method: &MojoFunction, output: &mut String) {
        output.push_str(&format!("    fn {}(", method.name));

        let params: Vec<String> = method
            .params
            .iter()
            .map(|p| self.format_parameter(p))
            .collect();
        output.push_str(&params.join(", "));
        output.push_str(") -> ");
        output.push_str(&self.type_to_string(&method.return_type));

        if let Some(body) = &method.body {
            output.push_str(":\n");
            output.push_str("        ");
            output.push_str(body);
            output.push_str("\n");
        } else {
            output.push_str(":\n");
            output.push_str("        pass\n");
        }
    }

    fn generate_mojo_trait(&self, trait_: &MojoTrait, output: &mut String) {
        output.push_str(&format!("trait {}:\n", trait_.name));

        if !trait_.constraints.is_empty() {
            output.push_str(&format!("    # Constraints: {:?}\n", trait_.constraints));
        }

        for method in &trait_.methods {
            output.push_str(&format!("    fn {}(", method.name));
            let params: Vec<String> = method
                .params
                .iter()
                .map(|p| self.format_parameter(p))
                .collect();
            output.push_str(&params.join(", "));
            output.push_str(") -> ");
            output.push_str(&self.type_to_string(&method.return_type));
            output.push_str("\n");
        }

        output.push_str("\n");
    }

    fn format_parameter(&self, param: &MojoParameter) -> String {
        let inout = if param.is_inout { "inout " } else { "" };
        format!(
            "{}{}: {}",
            inout,
            param.name,
            self.type_to_string(&param.param_type)
        )
    }

    fn type_to_string(&self, ty: &MojoType) -> String {
        match ty {
            MojoType::Void => "None".to_string(),
            MojoType::Bool => "Bool".to_string(),
            MojoType::Int => "Int".to_string(),
            MojoType::Int8 => "Int8".to_string(),
            MojoType::Int16 => "Int16".to_string(),
            MojoType::Int32 => "Int32".to_string(),
            MojoType::Int64 => "Int64".to_string(),
            MojoType::UInt => "UInt".to_string(),
            MojoType::UInt8 => "UInt8".to_string(),
            MojoType::UInt16 => "UInt16".to_string(),
            MojoType::UInt32 => "UInt32".to_string(),
            MojoType::UInt64 => "UInt64".to_string(),
            MojoType::Float32 => "Float32".to_string(),
            MojoType::Float64 => "Float64".to_string(),
            MojoType::String => "String".to_string(),
            MojoType::Array(inner) => format!("Array[{}]", self.type_to_string(inner)),
            MojoType::SIMD(dtype, width) => {
                let dtype_str = match dtype.as_ref() {
                    MojoType::Float32 => "DType.float32",
                    MojoType::Float64 => "DType.float64",
                    MojoType::Int32 => "DType.int32",
                    _ => "DType.float32",
                };
                format!("SIMD[{}, {}]", dtype_str, width)
            }
            MojoType::Tensor => "Tensor[DType.float32]".to_string(),
            MojoType::Pointer(inner) => {
                format!("DTypePointer[{}]", self.type_to_string(inner))
            }
            MojoType::Reference(inner) => format!("Reference[{}]", self.type_to_string(inner)),
            MojoType::Fn => "fn".to_string(),
            MojoType::Struct(name) => name.clone(),
            MojoType::Trait(name) => format!("{}Trait", name),
            MojoType::AnyType => "AnyType".to_string(),
        }
    }

    pub fn set_options(&mut self, options: MojoFFIOptions) {
        self.options = options;
    }

    pub fn generate_gpu_kernel(&self, func: &MojoFunction) -> String {
        let mut output = String::new();

        output.push_str("# GPU Kernel\n");
        output.push_str("@register_passable(\"trivial\")\n");
        output.push_str(&format!("struct GPUKernel_{} {{\n", func.name));
        output.push_str(&format!("    @staticmethod\n"));
        output.push_str(&format!("    fn {}(", func.name));

        let params: Vec<String> = func
            .params
            .iter()
            .map(|p| self.format_parameter(p))
            .collect();
        output.push_str(&params.join(", "));
        output.push_str(") -> ");
        output.push_str(&self.type_to_string(&func.return_type));
        output.push_str(":\n");

        output.push_str("        let tid = thread_id()\n");
        output.push_str("        let block_id = block_id()\n");
        output.push_str("        let block_size = block_size()\n");
        output.push_str(&format!(
            "        let gid = block_id * block_size + tid\n\n"
        ));

        if let Some(body) = &func.body {
            output.push_str("        ");
            output.push_str(body);
        } else {
            output.push_str("        pass");
        }

        output.push_str("\n    }\n");
        output.push_str("}\n\n");

        output
    }
}

#[derive(Debug, Clone)]
pub enum MojoDeclaration {
    Struct(MojoStruct),
    Trait(MojoTrait),
    Function(MojoFunction),
}

pub fn map_chim_type_to_mojo(chim_type: &crate::Type) -> MojoType {
    match chim_type {
        crate::Type::CVoid => MojoType::Void,
        crate::Type::CBool => MojoType::Bool,
        crate::Type::CChar => MojoType::Int8,
        crate::Type::CShort => MojoType::Int16,
        crate::Type::CInt => MojoType::Int,
        crate::Type::CLong => MojoType::Int,
        crate::Type::CLongLong => MojoType::Int64,
        crate::Type::CUChar => MojoType::UInt8,
        crate::Type::CUShort => MojoType::UInt16,
        crate::Type::CUInt => MojoType::UInt,
        crate::Type::CULong => MojoType::UInt,
        crate::Type::CULongLong => MojoType::UInt64,
        crate::Type::CFloat => MojoType::Float32,
        crate::Type::CDouble => MojoType::Float64,
        crate::Type::CStr => MojoType::String,
        crate::Type::CVoidPtr => MojoType::Pointer(Box::new(MojoType::Void)),
        crate::Type::ISize => MojoType::Int,
        crate::Type::USize => MojoType::UInt,
        crate::Type::Pointer { target, .. } => {
            MojoType::Pointer(Box::new(map_chim_type_to_mojo(target)))
        }
        crate::Type::Array { element, length: _ } => {
            MojoType::Array(Box::new(map_chim_type_to_mojo(element)))
        }
        crate::Type::Function { params, ret, .. } => {
            let param_types: Vec<MojoType> =
                params.iter().map(|p| map_chim_type_to_mojo(p)).collect();
            let ret_type = map_chim_type_to_mojo(ret);
            MojoType::Struct(format!(
                "fn({}) -> {}",
                param_types
                    .iter()
                    .map(|t| format!("{}", t))
                    .collect::<Vec<_>>()
                    .join(", "),
                ret_type
            ))
        }
        crate::Type::Struct { name, .. } => MojoType::Struct(name.to_string()),
        _ => MojoType::AnyType,
    }
}
